<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Godot Engine"><meta name=description content="As many of you have probably heard, a new rendering backend is being worked on for Godot. One of the most common comments when evaluating godot by potential users is that, for 2D, Godot is awesome but for 3D it's pretty far from the mainstream alternatives.
For Godot 3.0 (our new release being worked on) we are working hard to change this."><meta name=theme-color content="#3d8fcc"><meta property="og:site_name" content="Godot Engine"><meta property="og:url" content="https://godotengine.org/article/godots-new-renderer-progress-report-1/"><meta name=twitter:site content="@godotengine"><meta property="og:title" content="Godot's new renderer, progress report #1"><meta property="og:description" content="As many of you have probably heard, a new rendering backend is being worked on for Godot. One of the most common comments when evaluating godot by potential users is that, for 2D, Godot is awesome but for 3D it's pretty far from the mainstream alternatives.
For Godot 3.0 (our new release being worked on) we are working hard to change this."><meta property="og:image" content="https://godotengine.org/storage/app/uploads/public/581/887/929/5818879291fdb843399564.png"><meta property="og:type" content="article"><meta name=twitter:card content="summary_large_image"><title>Godot's new renderer, progress report #1</title><link rel=alternate type=application/rss+xml title="Godot News" href=/rss.xml><link rel=icon href=/assets/favicon.png sizes=any><link rel=icon href=/assets/favicon.svg type=image/svg+xml><link rel=stylesheet href=/assets/css/main.css?111><link rel=stylesheet href=/assets/css/tobii.min.css><link rel=preload as=font href=/assets/fonts/Montserrat-Bold.woff2 crossorigin><link rel=preload as=font href=/assets/fonts/Montserrat-ExtraBold.woff2 crossorigin><link rel=me href=https://mastodon.gamedev.place/@godotengine><input type=checkbox id=nav_toggle_cb><header><div class="container flex align-center"><div id=nav_head><a href=/ id=logo-link><img class=nav-logo src=/assets/logo.svg width=136 height=48 alt="Godot Engine">
<img class="nav-logo dark-logo" src=/assets/logo_dark.svg width=136 height=48 alt="Godot Engine"></a>
<label for=nav_toggle_cb id=nav_toggle_btn><img src=/assets/icons/hamburger.svg width=24 height=24 alt="Main menu"></label></div><nav id=nav><ul class=left><li><a href=/features>Features</a><li class=only-on-mobile><a href=/showcase>Showcase</a><li><a href=/blog>Blog</a><li><a href=/community>Community</a><li><a href=/contact>About</a><li><a href=https://godotengine.org/asset-library/asset>Assets</a></ul><ul class=right><li><a href=/download/windows class=set-os-download-url>Download</a><li><a href=https://docs.godotengine.org>Learn</a><li><a href=https://docs.godotengine.org/en/stable/community/contributing/index.html>Contribute</a><li class=fund><a href=https://fund.godotengine.org>❤&#xFE0E; Donate</a></ul></nav></div></header><main><style>body{background-color:var(--background-color)}h1{margin-bottom:8px;margin-top:32px}:not(pre)>code{background:var(--code-background-color);padding:1px 4px;font-size:.95em;border-radius:3px}pre{background:var(--codeblock-background-color);color:var(--codeblock-color)}pre code{display:block;overflow-x:auto;padding:.5em}.date-big{line-height:2;margin-left:32px}article{background-color:var(--base-color);box-shadow:0 3px 2px rgba(0,0,0,.15)}figure{margin:0}figure img{margin:0}article img,article video{max-width:100%;height:auto;display:block;margin:auto;margin-top:16px;margin-bottom:16px}article h1{margin-top:64px}article h2,article h3,article h4{margin-top:42px}.article-info{display:flex;flex-direction:column;gap:8px}.article-metadata{display:flex;gap:24px;align-items:center;font-family:var(--header-font-family);margin-bottom:12px}@media(max-width:900px){.article-metadata{flex-direction:column;align-items:flex-start;gap:16px}}.article-author{color:var(--base-color-text-subtitle-date);font-weight:700;font-size:18px;flex-grow:1;display:flex;gap:12px;align-items:center}.article-author .avatar{border-radius:100%;margin:0}.article-author .by{color:var(--base-color-text-subtitle)}.article-metadata .date{color:var(--base-color-text-subtitle-date)}.article-metadata .date.post-recent-highlight{color:var(--post-recent-highlight-color);opacity:.8}.article-metadata .date.post-recent-highlight::after{font-size:80%;content:"NEW";border:2px solid var(--post-recent-highlight-color);padding:2px 3px;margin-left:8px}.tag.active{filter:saturate(.75)}@media screen and (min-width:900px){article .content{width:70%;margin:auto}}@media(max-width:900px){body{background-color:var(--base-color)}article{background-color:initial;box-shadow:none}article img:first-child,article video:first-child{max-width:100%}}</style><link rel=stylesheet href=/assets/css/highlight.obsidian.min.css><div class=container><article class=padded><div class="content article-container"><figure class=article-cover><img src=/storage/app/uploads/public/581/887/929/5818879291fdb843399564.png title alt=" " class=rounded-lg style=width:100%;height:auto;background-color:initial></figure><div class=article-info><h1>Godot's new renderer, progress report #1</h1><div class=article-metadata><div class=article-author><span>By:</span>
<img class=avatar width=25 height=25 src=/assets/images/authors/reduzio.webp alt="Juan Linietsky" loading=lazy>
<span class=by>Juan Linietsky</span></div><span class=date data-post-date="2016-11-01 00:00:00 +0000">1 November 2016</span></div><div class=tags><a href=/blog/progress-report><div class="tag active">Progress Report</div></a></div></div><div class="card card-warning"><p>This article is from <strong>November 2016</strong>, some of its contents might be outdated and no longer accurate.<br>You can find up-to-date information about the engine in the <a href=https://docs.godotengine.org/en/stable/>official documentation</a>.</div><div class=article-body><h2 id=introduction>Introduction</h2><p>As many of you have probably heard, a new rendering backend is being worked on for Godot. One of the most common comments from potential users evaluating Godot is that, for 2D, Godot is awesome but for 3D it’s pretty far from the mainstream alternatives.<p>For Godot 3.0 (our upcoming release) we are working hard to change this.<p>Our goal is to have a modern, clustered renderer that supports everything mainstream engines support, including PBR, global illumination and flexible shader editing. As always, honoring the Godot tradition, this renderer will be super easy to use and run on as many platforms as possible.<p>If you want to know more about what’s going on, please keep an eye to our <a href=https://godotengine.org/devblog>devblog</a>.<h2 id=roadmap>Roadmap</h2><p>To add more insights, here is a roadmap about the things that need to be done to make the new renderer that will match our objectives, divided in what is done, and what still needs to be done:<h4 id=done-for-milestone-1-october-2016>Done for Milestone #1 (October 2016):</h4><ul><li>Make Godot compile against GLES 3.<li><a href=/article/change-image>Refactor the Image class to include modern data types</a>.<li>Refactor the texture API to include more modern texture compression formats.<li>Refactor the rendering API to make it easier to understand (and contribute to!).<li><a href=/article/making-shaders-more-accessible>Write a more flexible, GLES 3 GLSL compatible shader language</a>.<li>Write a more efficient Mesh format, which allows faster loading/saving.<li>Optimize scene rendering to use less function calls.<li>Make rendering always happen in Linear colorspace.<li>Investigate Physically Based Rendering (PBR), using GGX and alternatives.<li>Investigate cubemap filtering.<li>Create a new FixedMaterial that reflects PBR capabilities.<li>Implement PBR.<li>Convert gizmos to use the new FixedMaterial.<li>Add Lighting using PBR.<li>Investigate a ShadowAtlas allocation strategy.</ul><h4 id=todo-for-milestone-2-november-2016>TODO for Milestone #2 (November 2016)</h4><ul><li>Implement ShadowMapping.<li>Implement Environment Probes (research cubemap, dual paraboloid).<li>Implement Environment Probe and/or Skybox dynamic blending.<li>Implement more PBR parameters: Sheen, Clearcoat, Anisotropy.<li>Implement more Material parameters: Displacement, Refraction, Subsurface Scattering.<li>Implement Post-Processings: Tonemapping, adjustments, Motion Blur, SSAO, DOF Blur, Bloom and Screen Space Reflections.<li>Implement more types of geometry: Instancing (MultiMesh), Skeletons, and Immediates.<li>Implement Decals.</ul><h4 id=todo-for-milestone-3-december-2016>TODO for Milestone #3 (December 2016)</h4><ul><li>Implement the new version of the Godot SVO-based Light Baker.<li>Implement Particle Shaders, with support for: Sorting, Collision and Soft Particles.<li>Improve Culling: Portals (rewrite as polygon-based) and Rooms.<li>Add Clustered lighting (before this all is forward).<li>Add Layered/Stencil rendering.</ul><h4 id=wishlist>Wishlist!</h4><ul><li>Add VR Support (Vive, Rift, Daydream).</ul><h2 id=details-about-milestone-1>Details about Milestone #1</h2><p>Following are the details and explanations of what each of the tasks that Milestone 1 consisted of:<h3 id=make-godot-compile-against-gles-3>Make Godot compile against GLES 3</h3><p>Godot 2.1 compiles for OpenGL ES 2.0 by default. This task consisted in adjusting the headers and includes to use the OpenGL ES 3.0 version.<p>Currently, development is done under Linux using the <a href=http://www.mesa3d.org/>MESA driver</a>, which has full OpenGL ES 3.0 support, included the <code class="language-plaintext highlighter-rouge">#version 300 es</code> shaders.<p>Questions that often arise are:<ul><li>Why don’t you add features incrementally or make GLES 3 features optional?<li>Why don’t you use a backend library such as <a href=https://github.com/bkaradzic/bgfx>BGFX</a> and forget about writing for different OpenGL versions?</ul><p>The answer to this is that the main difference between OpenGL ES 2.0 and OpenGL ES 3.0 does not lie in “what extra things you can do”. Instead, it is more a matter that everything is done differently. As pretty much everything is done differently and more efficiently in OpenGL ES 3.0, making functionality optional does not make any sense. As such, ports for different platforms must be kept separate as they share little code.<p>Here are some examples of this:<h4 id=shaders-in-es-20-vs-es-30>Shaders in ES 2.0 vs ES 3.0</h4><p>OpenGL ES 3.0 supports many things that ES 2.0 does not, mainly integer types, integer samplers, etc. The syntax is also different, as ES 3.0 uses the more flexible concepts of in/outs (while ES 2.0 uses varying and more constants). The shaders being therefore completely different, reusing them is out of the question:<p><img src=/storage/app/media/devlog/progress1/progress_1_glsl.png alt><p>As you can see above with a piece of code from the canvas rendering shader, both OpenGL ES versions differ significantly in syntax and features.<p>In ES 2.0, all uniforms must be set individually, while in ES 3.0 you can use UBOs (Uniform Blocks) which are really useful and handy. UBOs can be set once and shared between all shaders and shader variants. The lack of these in ES 2.0 produces shaders that are bigger and their parameters must be set via several function calls.<p>A nice example of how UBOs make everything simpler and more efficient is in the piece of C++ code that sets up the light parameters into a shader in the OpenGL ES 2.0 backend:<p><img src=/storage/app/media/devlog/progress1/progress_1_ubo.png alt><p>And now the same version in the OpenGL ES 3.0 backend, using UBOs:<p><img src=/storage/app/media/devlog/progress1/progress_1_ubo2.png alt><p>Fantastic, isn’t it? In ES 2.0, the light type must be transferred into the shader by setting individual parameters (uniforms) and, if the shader changed, the setup function has to be called again.<p>In ES 3.0, the parameters are in a shared structure. It’s only set once until the light changes, and is shared between all shader versions.<h4 id=arrays-in-opengl-es-20-vs-30>Arrays in OpenGL ES 2.0 vs 3.0</h4><p>Likewise, vertex arrays are hugely more efficient. In ES 2.0, each array pointer (normals, vertices, tangents, uvs, etc.) had to be set up manually for each type of geometry. In 3.0, dozens of calls are replaced by a single call to <code class="language-plaintext highlighter-rouge">glBindVertexArray()</code>, via VAO (vertex array objects).<h4 id=skeletons-and-blend-shapes-in-opengl-es-20-vs-30>Skeletons and Blend Shapes in OpenGL ES 2.0 vs 3.0</h4><p>Skeletons are more or less the same in 3.0 (drawn via texture), except that it always works using hardware (ES 2.0 does not mandate vertex texture fetch).<p>For Blend Shapes, Transform Feedback can be used, which allows them to work using hardware acceleration.<p>In the ES 2.0 backend, they were both transformed using the CPU, resulting in a huge performance degradation.<h4 id=instancing-multimesh-in-opengl-es-20-vs-30>Instancing (MultiMesh) in OpenGL ES 2.0 vs 3.0</h4><p>OpenGL ES 3.0 provides hardware instancing (<code class="language-plaintext highlighter-rouge">glDrawArraysInstanced</code>), which means that MultiMesh can be drawn using a single draw call in 3.0, vs multiple calls in 2.0.<p>As a result, some stuff such as foliage (grass), gridmaps, etc. can get a huge performance boost.<h4 id=particles-in-es-30>Particles in ES 3.0</h4><p>Thanks to Transform Feedback, it is possible to process particles using the GPU. This means that dozens of thousands of particles can be drawn effortlessly, and include some features such as collision against the static environment by capturing depth/normal maps.<p>As the above features are implemented in the following milestone, more work will be documented.<h3 id=refactor-image-class-to-include-modern-data-types>Refactor Image class to include modern data types</h3><p>The Image class had to be refactored for more modern data types. There is a nice <a href=https://godotengine.org/article/change-image>devblog post</a> explaining what was done.<h3 id=refactor-texture-api-to-include-more-modern-texture-compression-formats>Refactor texture API to include more modern texture compression formats</h3><p>This is covered in the above-mentioned devblog post too.<h3 id=refactor-the-rendering-api-to-make-it-easier-to-understand>Refactor the rendering API to make it easier to understand</h3><p>The rendering API itself (VisualServer class) will not change much. There is also another <a href=https://godotengine.org/article/why-does-godot-use-servers-and-rids>devblog post</a> explaining the rationale behind it.<p>That said, what did change is the internals of it. For the GLES 2.0 renderer, every single feature was packed into a <a href=https://github.com/godotengine/godot/blob/2.1/drivers/gles2/rasterizer_gles2.cpp>single file</a>. For Godot 3.0, we are splitting it into <a href=https://github.com/godotengine/godot/tree/gles3/drivers/gles3>several files</a>.<p>The aim behind this is to make it easier to understand. Too many programmers complained of the code being too packed and cryptic.<p>The class design of the new visual server and rasterizer is like this:<p><img src=/storage/app/media/devlog/progress1/progress_1_visual_server.png alt><p>Each element is explained below:<ul><li><strong>VisualServer</strong>: Common API filter for all things visual.<li><strong>VisualServerViewport</strong>: Core code that goes through all viewports and draws them.<li><strong>VisualServerCanvas</strong>: All the logic behind 2D drawing, such as figuring out which CanvasItems are visible, the order of drawing (depending on Canvas and Z), the matching of lights and items, etc.<li><strong>RasterizerCanvas</strong>: An abstract class that is implemented by each platform. It receives the list of items, lights, etc. to draw and displays them into the screen.<li><strong>VisualServerScene</strong>: Contains all the 3D scene logic, such as spatial indexing, cameras, instancing, light pairing, portals, rooms, environment probes, etc. It performs scene culling from the camera and generates the list of lights and geometries that are visible for rendering.<li><strong>RasterizerScene</strong>: An abstract class that is implemented by each platform. It receives a list of geometries and lights for rendering.<li><strong>RasterizerStorage</strong>: The final abstract class. It manages resource storage such as textures, meshes, skeletons, etc.</ul><h3 id=write-a-more-flexible-gles-3-glsl-compatible-shader-language>Write a more flexible, GLES 3 GLSL compatible shader language</h3><p>A <a href=https://godotengine.org/article/making-shaders-more-accessible>devblog entry</a> about this was already written, should be informative enough.<h3 id=write-a-more-efficient-mesh-format-which-allows-faster-loadingsaving>Write a more efficient Mesh format, which allows faster loading/saving</h3><p>Godot used to run in plenty of platforms in the past, such as:<ul><li>Fixed pipeline PC<li>OpenGL 2.1<li>DirectX 9<li>Sony PSP<li>Sony PS3<li>Sony PSVita<li>etc.</ul><p>Different platforms used different formats for storing vertex array data, and even endianness (e.g. PS3 was big-endian) would affect the format. To overcome this limitation, Godot stored this data as individual, uncompressed arrays and then converted it to each platform on the rendering backend at load-time.<p>Nowadays, vertex data is more or less standard, and all relevant platforms are little-endian. As such, we can safely store a big chunk of binary data and a small description of where everything is.<p>This makes loading/saving meshes much more efficient.<h3 id=optimize-scene-rendering-to-use-less-function-calls>Optimize scene rendering to use less function calls</h3><p>The Godot 2.x scene API performed a single function call into the rasterizer for adding each element to a render list. In Godot 3.0, a whole list is passed in a single virtual function call.<p>This should improve performance considerably but, as a result, more data had to be exposed by the Rasterizer API. This was solved by adding a <code class="language-plaintext highlighter-rouge">RasterizerSceneGLES3::InstanceBase</code> class.<h3 id=make-rendering-always-happen-in-linear-colorspace>Make rendering always happen in Linear colorspace</h3><p>Texture and color information edited by users exists only in the SRGB colorspace. This happens because monitor colors are adjusted by a Gamma function, elevating them to a roughly 2.2 or 2.4 power.<p>To make lighting more realistic, all computations must happen in a linear color space, then converted to Gamma at the end via tonemapping.<p>Godot 2.x already supported linear space rendering, but this was optional. In 3.0, as we are aiming to a more realistic and high quality backend, the only supported rendering mode is linear.<h3 id=investigate-physically-based-rendering-pbr-using-ggx-and-alternatives>Investigate Physically Based Rendering (PBR), using GGX and alternatives</h3><p>Thorough investigation was carried out on more modern rendering techniques for Godot.<p>As a result, we decided to use the <a href=https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf>Disney PBR</a> specification.<p>Godot will use a similar parameter set for materials and shaders.<h3 id=investigate-cubemap-filtering>Investigate cubemap filtering</h3><p>The most common way to implement PBR in real-time is to use a pre-filtered cubemap for material roughness. This makes the reflected light more or less smoothed on demand:<p><img src=/storage/app/media/devlog/progress1/progress_1_pbr.png alt><p>Cubemap filtering was implemented and it’s working well, but doubts arise whether using this or dual paraboloid maps is better. The reason is that cubemaps don’t blend well between cube sides in several platforms.<h3 id=create-a-new-fixedmaterial-that-reflects-pbr-capabilities>Create a new FixedMaterial that reflects PBR capabilities</h3><p>A new FixedSceneMaterial resource was created, which allows editing simple materials without having to edit shaders manually. It also has the advtange of reusing shaders for similar material configurations:<p><img src=/storage/app/media/devlog/progress1/progress_1_material.png alt><h3 id=implement-pbr>Implement PBR</h3><p>The minimum required parameters for PBR are implemented and working:<ul><li>Albedo<li>Specular<li>Roughness<li>Environment (skybox)</ul><h3 id=convert-gizmos-to-use-the-new-fixedmaterial>Convert gizmos to use the new FixedMaterial</h3><p>All gizmos were converted to use the new FixedSceneMaterial, as mentioned before.<h3 id=add-lighting-using-pbr>Add Lighting using PBR</h3><p>Additive lighting has been added for the PBR backend (in Milestone 3, clustered lighting will be added).<p><img src=/storage/app/media/devlog/progress1/progress_1_lighting.png alt><h3 id=investigate-a-shadowatlas-allocation-strategy>Investigate a ShadowAtlas allocation strategy</h3><p>Godot 2.0 used individual textures for each shadow map. In the wake of more modern techniques such as clustered renderering, it is required that all shadowmaps are contained within a single texture.<p>Research was done first into dynamic allocation strategies for light shadows into a shadow atlas, but nothing useful was found. Every dynamic scheme implies moving around shadowmaps if no more space is available, which incurs a considerable cost.<p>In the end, a more static approach will take place. The shadow atlas will be divided into 4 “Quadrants” and the user will be able to specify how they want each of them subdivided. A default subdivision should cover most use cases:<p><img src=/storage/app/media/devlog/progress1/progress_1_atlas.png alt><p>But the possibility is open for developers to tweak this subdivision for games that might look better with a different scheme.<p>The logic to tell which cell size must be used for which light is straightforward. Every time the camera moves, each visible light computes a “coverage” value, which represents their size on screen, as example:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>average_screen_size = (screen_width + screen_height) / 2
coverage = diameter_in_screen_pixels / average_screen_size
</code></pre></div></div><p>The coverage is then a value ranging from 0 to 1. To determine which cell size it must be used, the following logic applies:<div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>desired_cell_size = nearest_power_of_2(largest_cell_size * coverage)
</code></pre></div></div><h2 id=future>Future</h2><p>This has been our first report on the new renderer progress towards Godot 3.0 new renderer, hope everything was clear!<h2 id=seeing-the-code>Seeing the code</h2><p>If you are interested in seeing what each feature looks like in the code, you can check the <a href=https://github.com/godotengine/godot/commits/gles3><em>gles3</em> branch</a> on GitHub.</div></div></article></div><link rel=stylesheet href=/assets/css/anchor-link.css?1><link rel=stylesheet href=/assets/css/article-cards.css?2><script src=/assets/js/anchor-link.js></script>
<script>document.addEventListener('DOMContentLoaded',()=>{window.applyAnchorLinks('.article-body'),document.querySelectorAll('.article-cover img, .article-body img').forEach(b=>{if(b.classList.contains('lightbox-ignore'))return;const a=document.createElement('a');a.href=b.src,a.classList.add('lightbox'),a.dataset.group='article',b.parentNode.appendChild(a),a.appendChild(b)})})</script></main><footer><div class="container flex footer-container"><div id=copyright><p>© 2007-2024 Juan Linietsky, Ariel Manzur and <a href=https://github.com/godotengine/godot/blob/master/AUTHORS.md target=_blank rel=noopener>contributors</a>.<br>Hosted by the <a href=https://godot.foundation/ target=_blank rel=noopener>Godot Foundation</a>.<br>Website <a href=https://github.com/godotengine/godot-website target=_blank rel=noopener>source code on GitHub</a>.</div><div id=sitemap><ul class=sitemap-group><li><strong>Get Godot</strong><li><a href=/download/windows class=set-os-download-url>Download</a><li><a href=https://editor.godotengine.org/releases/latest/>Web Editor</a><li>&nbsp;<li><strong>Public Relations</strong><li><a href=/blog>Blog</a><li><a href=/community>Communities and Events</a><li><a href=/press>Press Kit</a></ul><ul class=sitemap-group><li><strong>About Godot</strong><li><a href=/features>Features</a><li><a href=/showcase>Showcase</a><li><a href=/education>Education</a><li><a href=/license>License</a><li><a href=/code-of-conduct>Code of Conduct</a><li><a href=/privacy-policy>Privacy Policy</a><li><a href=https://fund.godotengine.org>Donate</a></ul><ul class=sitemap-group><li><strong>Project Team</strong><li><a href=/governance>Governance</a><li><a href=/teams>Teams</a><li>&nbsp;<li><strong>Extra Resources</strong><li><a href=/asset-library/asset>Asset Library</a><li><a href=https://docs.godotengine.org>Documentation</a><li><a href=https://github.com/godotengine>Code Repository</a></ul></div><div id=social class=dark-desaturate><h4 class=text-right><a href=/contact>Contact us</a></h4><div class="flex justify-space-between" style=gap:3px><a href=https://github.com/godotengine target=_blank rel=noopener><img src=/assets/footer/github_logo.svg width=32 height=32 alt=GitHub></a>
<a href=https://mastodon.gamedev.place/@godotengine target=_blank rel=noopener><img src=/assets/footer/mastodon_logo.svg width=32 height=32 alt=Mastodon></a>
<a href=https://twitter.com/godotengine target=_blank rel=noopener><img src=/assets/footer/twitter_logo.svg width=32 height=32 alt=Twitter></a>
<a href=https://www.facebook.com/groups/godotengine/ target=_blank rel=noopener><img src=/assets/footer/facebook_logo.svg width=32 height=32 alt=Facebook></a>
<a href=https://www.reddit.com/r/godot target=_blank rel=noopener><img src=/assets/footer/reddit_logo.svg width=32 height=32 alt=Red​dit></a>
<a href=/rss.xml target=_blank rel=noopener><img src=/assets/footer/feed_logo.svg width=32 height=32 alt="RSS feed"></a></div></div></div></footer><script defer src=/assets/js/tobii.min.js></script>
<script defer src=/assets/js/highlight.min.js?1></script>
<script defer src=/assets/js/highlight.gdscript.min.js?1></script>
<script>document.addEventListener('DOMContentLoaded',()=>{document.querySelectorAll('pre code').forEach(a=>{hljs.highlightBlock(a)}),document.querySelectorAll('[data-post-date]').forEach(a=>{Date.parse(a.dataset.postDate)>Date.now()-1e3*60*60*48&&a.classList.add("post-recent-highlight")}),new Tobii({zoom:!1});const a=document.querySelectorAll('.set-os-download-url');for(let b=0;b<a.length;b++){const c=a[b];let e='download';'version'in c.dataset&&c.dataset.version==='3'&&(e='download/3.x');let d='windows';navigator.platform.indexOf('Mac')!==-1?d='macos':navigator.platform.indexOf('Linux')!==-1&&(d='linux'),c.href=`/${e}/${d}`}})</script>