import{BufferAttribute,BufferGeometry,Float32BufferAttribute,InstancedBufferAttribute,InterleavedBuffer,InterleavedBufferAttribute,TriangleFanDrawMode,TriangleStripDrawMode,TrianglesDrawMode,Vector3,}from"./three.module.min.js";function computeMikkTSpaceTangents(e,t,n=!0){if(!t||!t.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!e.hasAttribute("position")||!e.hasAttribute("normal")||!e.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function o(e){if(e.normalized||e.isInterleavedBufferAttribute){const t=new Float32Array(e.count*e.itemSize);for(let n=0,s=0;n<e.count;n++)t[s++]=e.getX(n),t[s++]=e.getY(n),e.itemSize>2&&(t[s++]=e.getZ(n));return t}return e.array instanceof Float32Array?e.array:new Float32Array(e.array)}const s=e.index?e.toNonIndexed():e,i=t.generateTangents(o(s.attributes.position),o(s.attributes.normal),o(s.attributes.uv));if(n)for(let e=3;e<i.length;e+=4)i[e]*=-1;return s.setAttribute("tangent",new BufferAttribute(i,4)),e!==s&&e.copy(s),e}function mergeGeometries(e,t=!1){const i=e[0].index!==null,a=new Set(Object.keys(e[0].attributes)),c=new Set(Object.keys(e[0].morphAttributes)),o={},s={},l=e[0].morphTargetsRelative,n=new BufferGeometry;let r=0;for(let d=0;d<e.length;++d){const u=e[d];let h=0;if(i!==(u.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+d+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in u.attributes){if(!a.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+d+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;o[e]===void 0&&(o[e]=[]),o[e].push(u.attributes[e]),h++}if(h!==a.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+d+". Make sure all geometries have the same number of attributes."),null;if(l!==u.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+d+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in u.morphAttributes){if(!c.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+d+".  .morphAttributes must be consistent throughout all geometries."),null;s[e]===void 0&&(s[e]=[]),s[e].push(u.morphAttributes[e])}if(t){let e;if(i)e=u.index.count;else if(u.attributes.position!==void 0)e=u.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+d+". The geometry must have either an index or a position attribute"),null;n.addGroup(r,e,d),r+=e}}if(i){let t=0;const s=[];for(let n=0;n<e.length;++n){const o=e[n].index;for(let e=0;e<o.count;++e)s.push(o.getX(e)+t);t+=e[n].attributes.position.count}n.setIndex(s)}for(const e in o){const t=mergeAttributes(o[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;n.setAttribute(e,t)}for(const e in s){const t=s[e][0].length;if(t===0)break;n.morphAttributes=n.morphAttributes||{},n.morphAttributes[e]=[];for(let o=0;o<t;++o){const i=[];for(let t=0;t<s[e].length;++t)i.push(s[e][t][o]);const a=mergeAttributes(i);if(!a)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;n.morphAttributes[e].push(a)}}return n}function mergeAttributes(e){let s,t,o,n=-1,r=0;for(let a=0;a<e.length;++a){const i=e[a];if(s===void 0&&(s=i.array.constructor),s!==i.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(t===void 0&&(t=i.itemSize),t!==i.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(o===void 0&&(o=i.normalized),o!==i.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(n===-1&&(n=i.gpuType),n!==i.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;r+=i.count*t}const c=new s(r),i=new BufferAttribute(c,t,o);let a=0;for(let s=0;s<e.length;++s){const n=e[s];if(n.isInterleavedBufferAttribute){const e=a/t;for(let s=0,o=n.count;s<o;s++)for(let o=0;o<t;o++){const a=n.getComponent(s,o);i.setComponent(s+e,o,a)}}else c.set(n.array,a);a+=n.count*t}return n!==void 0&&(i.gpuType=n),i}function deepCloneAttribute(e){return e.isInstancedInterleavedBufferAttribute||e.isInterleavedBufferAttribute?deinterleaveAttribute(e):e.isInstancedBufferAttribute?(new InstancedBufferAttribute).copy(e):(new BufferAttribute).copy(e)}function interleaveAttributes(e){let t,n=0,s=0;for(let i=0,a=e.length;i<a;++i){const o=e[i];if(t===void 0&&(t=o.array.constructor),t!==o.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;n+=o.array.length,s+=o.itemSize}const a=new InterleavedBuffer(new t(n),s);let o=0;const i=[],r=["getX","getY","getZ","getW"],c=["setX","setY","setZ","setW"];for(let n=0,d=e.length;n<d;n++){const t=e[n],s=t.itemSize,u=t.count,l=new InterleavedBufferAttribute(a,s,o,t.normalized);i.push(l),o+=s;for(let e=0;e<u;e++)for(let n=0;n<s;n++)l[c[n]](e,t[r[n]](e))}return i}function deinterleaveAttribute(e){const a=e.data.array.constructor,s=e.count,n=e.itemSize,o=e.normalized,i=new a(s*n);let t;e.isInstancedInterleavedBufferAttribute?t=new InstancedBufferAttribute(i,n,o,e.meshPerAttribute):t=new BufferAttribute(i,n,o);for(let o=0;o<s;o++)t.setX(o,e.getX(o)),n>=2&&t.setY(o,e.getY(o)),n>=3&&t.setZ(o,e.getZ(o)),n>=4&&t.setW(o,e.getW(o));return t}function deinterleaveGeometry(e){const n=e.attributes,s=e.morphTargets,t=new Map;for(const s in n){const e=n[s];e.isInterleavedBufferAttribute&&(t.has(e)||t.set(e,deinterleaveAttribute(e)),n[s]=t.get(e))}for(const n in s){const e=s[n];e.isInterleavedBufferAttribute&&(t.has(e)||t.set(e,deinterleaveAttribute(e)),s[n]=t.get(e))}}function estimateBytesUsed(e){let n=0;for(const s in e.attributes){const t=e.getAttribute(s);n+=t.count*t.itemSize*t.array.BYTES_PER_ELEMENT}const t=e.getIndex();return n+=t?t.count*t.itemSize*t.array.BYTES_PER_ELEMENT:0,n}function mergeVertices(e,t=1e-4){t=Math.max(t,Number.EPSILON);const l={},i=e.getIndex(),v=e.getAttribute("position"),h=i?i.count:v.count;let s=0;const o=Object.keys(e.attributes),c={},n={},r=[],d=["getX","getY","getZ","getW"],m=["setX","setY","setZ","setW"];for(let i=0,r=o.length;i<r;i++){const t=o[i],s=e.attributes[t];c[t]=new s.constructor(new s.array.constructor(s.count*s.itemSize),s.itemSize,s.normalized);const a=e.morphAttributes[t];a&&(n[t]||(n[t]=[]),a.forEach((e,s)=>{const o=new e.array.constructor(e.count*e.itemSize);n[t][s]=new e.constructor(o,e.itemSize,e.normalized)}))}const f=t*.5,p=Math.log10(1/t),u=Math.pow(10,p),g=f*u;for(let t=0;t<h;t++){const f=i?i.getX(t):t;let a="";for(let t=0,s=o.length;t<s;t++){const i=o[t],n=e.getAttribute(i),r=n.itemSize;for(let e=0;e<r;e++)a+=`${~~(n[d[e]](f)*u+g)},`}if(a in l)r.push(l[a]);else{for(let i=0,l=o.length;i<l;i++){const t=o[i],r=e.getAttribute(t),a=e.morphAttributes[t],u=r.itemSize,h=c[t],p=n[t];for(let e=0;e<u;e++){const t=d[e],n=m[e];if(h[n](s,r[t](f)),a)for(let e=0,o=a.length;e<o;e++)p[e][n](s,a[e][t](f))}}l[a]=s,r.push(s),s++}}const a=e.clone();for(const t in e.attributes){const o=c[t];if(a.setAttribute(t,new o.constructor(o.array.slice(0,s*o.itemSize),o.itemSize,o.normalized)),!(t in n))continue;for(let o=0;o<n[t].length;o++){const e=n[t][o];a.morphAttributes[t][o]=new e.constructor(e.array.slice(0,s*e.itemSize),e.itemSize,e.normalized)}}return a.setIndex(r),a}function toTrianglesDrawMode(e,t){if(t===TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===TriangleFanDrawMode||t===TriangleStripDrawMode){let n=e.getIndex();if(n===null){const t=[],s=e.getAttribute("position");if(s!==void 0){for(let e=0;e<s.count;e++)t.push(e);e.setIndex(t),n=e.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e}const o=n.count-2,s=[];if(t===TriangleFanDrawMode)for(let e=1;e<=o;e++)s.push(n.getX(0)),s.push(n.getX(e)),s.push(n.getX(e+1));else for(let e=0;e<o;e++)e%2===0?(s.push(n.getX(e)),s.push(n.getX(e+1)),s.push(n.getX(e+2))):(s.push(n.getX(e+2)),s.push(n.getX(e+1)),s.push(n.getX(e)));s.length/3!==o&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=e.clone();return i.setIndex(s),i.clearGroups(),i}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}function computeMorphedAttributes(e){const j=new Vector3,b=new Vector3,v=new Vector3,S=new Vector3,F=new Vector3,M=new Vector3,E=new Vector3,x=new Vector3,k=new Vector3;function d(e,t,n,s,o,i,a,r){j.fromBufferAttribute(t,o),b.fromBufferAttribute(t,i),v.fromBufferAttribute(t,a);const c=e.morphTargetInfluences;if(n&&c){E.set(0,0,0),x.set(0,0,0),k.set(0,0,0);for(let t=0,l=n.length;t<l;t++){const e=c[t],r=n[t];if(e===0)continue;S.fromBufferAttribute(r,o),F.fromBufferAttribute(r,i),M.fromBufferAttribute(r,a),s?(E.addScaledVector(S,e),x.addScaledVector(F,e),k.addScaledVector(M,e)):(E.addScaledVector(S.sub(j),e),x.addScaledVector(F.sub(b),e),k.addScaledVector(M.sub(v),e))}j.add(E),b.add(x),v.add(k)}e.isSkinnedMesh&&(e.applyBoneTransform(o,j),e.applyBoneTransform(i,b),e.applyBoneTransform(a,v)),r[o*3+0]=j.x,r[o*3+1]=j.y,r[o*3+2]=j.z,r[i*3+0]=b.x,r[i*3+1]=b.y,r[i*3+2]=b.z,r[a*3+0]=v.x,r[a*3+1]=v.y,r[a*3+2]=v.z}const u=e.geometry,T=e.material;let n,a,i;const c=u.index,r=u.attributes.position,A=u.morphAttributes.position,p=u.morphTargetsRelative,g=u.attributes.normal,w=u.morphAttributes.position,O=u.groups,o=u.drawRange;let t,s,f,C,m,h,l;const _=new Float32Array(r.count*r.itemSize),y=new Float32Array(g.count*g.itemSize);if(c!==null)if(Array.isArray(T))for(t=0,f=O.length;t<f;t++){m=O[t],h=Math.max(m.start,o.start),l=Math.min(m.start+m.count,o.start+o.count);for(s=h,C=l;s<C;s+=3)n=c.getX(s),a=c.getX(s+1),i=c.getX(s+2),d(e,r,A,p,n,a,i,_),d(e,g,w,p,n,a,i,y)}else{h=Math.max(0,o.start),l=Math.min(c.count,o.start+o.count);for(t=h,f=l;t<f;t+=3)n=c.getX(t),a=c.getX(t+1),i=c.getX(t+2),d(e,r,A,p,n,a,i,_),d(e,g,w,p,n,a,i,y)}else if(Array.isArray(T))for(t=0,f=O.length;t<f;t++){m=O[t],h=Math.max(m.start,o.start),l=Math.min(m.start+m.count,o.start+o.count);for(s=h,C=l;s<C;s+=3)n=s,a=s+1,i=s+2,d(e,r,A,p,n,a,i,_),d(e,g,w,p,n,a,i,y)}else{h=Math.max(0,o.start),l=Math.min(r.count,o.start+o.count);for(t=h,f=l;t<f;t+=3)n=t,a=t+1,i=t+2,d(e,r,A,p,n,a,i,_),d(e,g,w,p,n,a,i,y)}const z=new Float32BufferAttribute(_,3),D=new Float32BufferAttribute(y,3);return{positionAttribute:r,normalAttribute:g,morphedPositionAttribute:z,morphedNormalAttribute:D}}function mergeGroups(e){if(e.groups.length===0)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),e;let t=e.groups;if(t=t.sort((e,t)=>e.materialIndex!==t.materialIndex?e.materialIndex-t.materialIndex:e.start-t.start),e.getIndex()===null){const n=e.getAttribute("position"),t=[];for(let e=0;e<n.count;e+=3)t.push(e,e+1,e+2);e.setIndex(t)}const i=e.getIndex(),s=[];for(let e=0;e<t.length;e++){const n=t[e],o=n.start,a=o+n.count;for(let e=o;e<a;e++)s.push(i.getX(e))}e.dispose(),e.setIndex(s);let o=0;for(let e=0;e<t.length;e++){const n=t[e];n.start=o,o+=n.count}let n=t[0];e.groups=[n];for(let s=1;s<t.length;s++){const o=t[s];n.materialIndex===o.materialIndex?n.count+=o.count:(n=o,e.groups.push(n))}return e}function toCreasedNormals(e,t=Math.PI/3){const m=Math.cos(t),l=(1+1e-10)*100,s=[new Vector3,new Vector3,new Vector3],i=new Vector3,a=new Vector3,d=new Vector3,o=new Vector3;function u(e){const t=~~(e.x*l),n=~~(e.y*l),s=~~(e.z*l);return`${t},${n},${s}`}const c=e.index?e.toNonIndexed():e,n=c.attributes.position,r={};for(let e=0,c=n.count/3;e<c;e++){const t=3*e,l=s[0].fromBufferAttribute(n,t+0),o=s[1].fromBufferAttribute(n,t+1),d=s[2].fromBufferAttribute(n,t+2);i.subVectors(d,o),a.subVectors(l,o);const h=(new Vector3).crossVectors(i,a).normalize();for(let e=0;e<3;e++){const n=s[e],t=u(n);t in r||(r[t]=[]),r[t].push(h)}}const f=new Float32Array(n.count*3),h=new BufferAttribute(f,3,!1);for(let t=0,l=n.count/3;t<l;t++){const e=3*t,f=s[0].fromBufferAttribute(n,e+0),c=s[1].fromBufferAttribute(n,e+1),p=s[2].fromBufferAttribute(n,e+2);i.subVectors(p,c),a.subVectors(f,c),d.crossVectors(i,a).normalize();for(let t=0;t<3;t++){const i=s[t],a=u(i),n=r[a];o.set(0,0,0);for(let e=0,s=n.length;e<s;e++){const t=n[e];d.dot(t)>m&&o.add(t)}o.normalize(),h.setXYZ(e+t,o.x,o.y,o.z)}}return c.setAttribute("normal",h),c}export{computeMikkTSpaceTangents,mergeGeometries,mergeAttributes,deepCloneAttribute,deinterleaveAttribute,deinterleaveGeometry,interleaveAttributes,estimateBytesUsed,mergeVertices,toTrianglesDrawMode,computeMorphedAttributes,mergeGroups,toCreasedNormals}