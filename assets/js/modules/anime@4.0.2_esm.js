const isBrowser=typeof window!="undefined",win=isBrowser?window:null,doc=isBrowser?document:null,tweenTypes={OBJECT:0,ATTRIBUTE:1,CSS:2,TRANSFORM:3,CSS_VAR:4},valueTypes={NUMBER:0,UNIT:1,COLOR:2,COMPLEX:3},tickModes={NONE:0,AUTO:1,FORCE:2},compositionTypes={replace:0,none:1,blend:2},isRegisteredTargetSymbol=Symbol(),isDomSymbol=Symbol(),isSvgSymbol=Symbol(),transformsSymbol=Symbol(),morphPointsSymbol=Symbol(),proxyTargetSymbol=Symbol(),minValue=1e-11,maxValue=1e12,K=1e3,maxFps=120,emptyString="",shortTransforms=new Map;shortTransforms.set("x","translateX"),shortTransforms.set("y","translateY"),shortTransforms.set("z","translateZ");const validTransforms=["translateX","translateY","translateZ","rotate","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","perspective","matrix","matrix3d"],transformsFragmentStrings=validTransforms.reduce((e,t)=>({...e,[t]:t+"("}),{}),noop=()=>{},hexTestRgx=/(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i,rgbExecRgx=/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i,rgbaExecRgx=/rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i,hslExecRgx=/hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i,hslaExecRgx=/hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i,digitWithExponentRgx=/[-+]?\d*\.?\d+(?:e[-+]?\d)?/gi,unitsExecRgx=/^([-+]?\d*\.?\d+(?:e[-+]?\d+)?)([a-z]+|%)$/i,lowerCaseRgx=/([a-z])([A-Z])/g,transformsExecRgx=/(\w+)(\([^)]+\)+)/g,relativeValuesExecRgx=/(\*=|\+=|-=)/,defaults={id:null,keyframes:null,playbackEase:null,playbackRate:1,frameRate:maxFps,loop:0,reversed:!1,alternate:!1,autoplay:!0,duration:K,delay:0,loopDelay:0,ease:"out(2)",composition:compositionTypes.replace,modifier:e=>e,onBegin:noop,onBeforeUpdate:noop,onUpdate:noop,onLoop:noop,onPause:noop,onComplete:noop,onRender:noop},globals={defaults,root:doc,scope:null,precision:4,timeScale:1,tickThreshold:200},globalVersions={version:"4.0.2",engine:null};isBrowser&&(win.AnimeJS||(win.AnimeJS=[]),win.AnimeJS.push(globalVersions));const toLowerCase=e=>e.replace(lowerCaseRgx,"$1-$2").toLowerCase(),stringStartsWith=(e,t)=>e.indexOf(t)===0,now=Date.now,isArr=Array.isArray,isObj=e=>e&&e.constructor===Object,isNum=e=>typeof e=="number"&&!isNaN(e),isStr=e=>typeof e=="string",isFnc=e=>typeof e=="function",isUnd=e=>typeof e=="undefined",isNil=e=>isUnd(e)||e===null,isSvg=e=>isBrowser&&e instanceof SVGElement,isHex=e=>hexTestRgx.test(e),isRgb=e=>stringStartsWith(e,"rgb"),isHsl=e=>stringStartsWith(e,"hsl"),isCol=e=>isHex(e)||isRgb(e)||isHsl(e),isKey=e=>!globals.defaults.hasOwnProperty(e),parseNumber=e=>isStr(e)?parseFloat(e):e,pow=Math.pow,sqrt=Math.sqrt,sin=Math.sin,cos=Math.cos,abs=Math.abs,exp=Math.exp,ceil=Math.ceil,floor=Math.floor,asin=Math.asin,max=Math.max,atan2=Math.atan2,PI=Math.PI,_round=Math.round,clamp=(e,t,n)=>e<t?t:e>n?n:e,powCache={},round=(e,t)=>{if(t<0)return e;if(!t)return _round(e);let n=powCache[t];return n||(n=powCache[t]=10**t),_round(e*n)/n},snap=(e,t)=>isArr(t)?t.reduce((t,n)=>abs(n-e)<abs(t-e)?n:t):t?_round(e/t)*t:e,interpolate=(e,t,n)=>e+(t-e)*n,clampInfinity=e=>e===1/0?maxValue:e===-(1/0)?-1e12:e,normalizeTime=e=>e<=minValue?minValue:clampInfinity(round(e,11)),cloneArray=e=>isArr(e)?[...e]:e,mergeObjects=(e,t)=>{const n={...e};for(let s in t){const o=e[s];n[s]=isUnd(o)?t[s]:o}return n},forEachChildren=(e,t,n,s="_prev",o="_next")=>{let i=e._head,a=o;for(n&&(i=e._tail,a=s);i;){const e=i[a];t(i),i=e}},removeChild=(e,t,n="_prev",s="_next")=>{const o=t[n],i=t[s];o?o[s]=i:e._head=i,i?i[n]=o:e._tail=o,t[n]=null,t[s]=null},addChild=(e,t,n,s="_prev",o="_next")=>{let i=e._tail;for(;i&&n&&n(i,t);)i=i[s];const a=i?i[o]:e._head;i?i[o]=t:e._head=t,a?a[s]=t:e._tail=t,t[s]=i,t[o]=a};class Clock{constructor(e=0){this.deltaTime=0,this._currentTime=e,this._elapsedTime=e,this._startTime=e,this._lastTime=e,this._scheduledTime=0,this._frameDuration=round(K/maxFps,0),this._fps=maxFps,this._speed=1,this._hasChildren=!1,this._head=null,this._tail=null}get fps(){return this._fps}set fps(e){const o=this._frameDuration,t=+e,n=t<minValue?minValue:t,s=round(K/n,0);this._fps=n,this._frameDuration=s,this._scheduledTime+=s-o}get speed(){return this._speed}set speed(e){const t=+e;this._speed=t<minValue?minValue:t}requestTick(e){const n=this._scheduledTime,t=this._elapsedTime;if(this._elapsedTime+=e-t,t<n)return tickModes.NONE;const s=this._frameDuration,o=t-n;return this._scheduledTime+=o<s?s:o,tickModes.AUTO}computeDeltaTime(e){const t=e-this._lastTime;return this.deltaTime=t,this._lastTime=e,t}}const render=(e,t,n,s,o)=>{const i=e.parent,a=e.duration,p=e.completed,h=e.iterationDuration,v=e.iterationCount,T=e._currentIteration,S=e._loopDelay,F=e._reversed,M=e._alternate,O=e._hasChildren,r=e._delay,w=e._currentTime,y=r+h,c=t-r,l=clamp(w,-r,a),b=clamp(c,-r,a),k=c-w,m=b>0,f=b>=a,E=a<=minValue,C=o===tickModes.FORCE;let x=0,_=c,j=0;if(v>1){const t=~~(b/(h+(f?0:S)));e._currentIteration=clamp(t,0,v),f&&e._currentIteration--,x=e._currentIteration%2,_=b%(h+S)||0}const g=F^(M&&x),A=e._ease;let u=f?g?0:a:g?h-_:_;A&&(u=h*A(u/h)||0);const d=(i?i.backwards:c<w)?!g:!!g;if(e._currentTime=c,e._iterationTime=u,e.backwards=d,m&&!e.began?(e.began=!0,!n&&!(i&&(d||!i.began))&&e.onBegin(e)):c<=0&&(e.began=!1),!n&&!O&&m&&e._currentIteration!==T&&e.onLoop(e),C||o===tickModes.AUTO&&(t>=r&&t<=y||t<=r&&l>r||t>=y&&l!==a)||u>=y&&l!==a||u<=r&&l>0||t<=l&&l===a&&p||f&&!p&&E){if(m&&(e.computeDeltaTime(l),n||e.onBeforeUpdate(e)),!O){const p=C||(d?k*-1:k)>=globals.tickThreshold,a=e._offset+(i?i._offset:0)+r+u;let t=e._head,o,c,f,l,h=0;for(;t;){const r=t._composition,d=t._currentTime,g=t._changeDuration,v=t._absoluteStartTime+t._changeDuration,e=t._nextRep,n=t._prevRep,i=r!==compositionTypes.none;if((p||(d!==g||a<=v+(e?e._delay:0))&&(d!==0||a>=t._absoluteStartTime))&&(!i||!t._isOverridden&&(!t._isOverlapped||a<=v)&&(!e||e._isOverridden||a<=e._absoluteStartTime)&&(!n||n._isOverridden||a>=n._absoluteStartTime+n._changeDuration+t._delay))){const w=t._currentTime=clamp(u-t._startTime,0,g),n=t._ease(w/t._updateDuration),a=t._modifier,p=t._valueType,d=t._tweenType,y=d===tweenTypes.OBJECT,_=p===valueTypes.NUMBER,v=_&&y||n===0||n===1?-1:globals.precision;let e,b;if(_)e=b=a(round(interpolate(t._fromNumber,t._toNumber,n),v));else if(p===valueTypes.UNIT)b=a(round(interpolate(t._fromNumber,t._toNumber,n),v)),e=`${b}${t._unit}`;else if(p===valueTypes.COLOR){{const s=t._fromNumbers,o=t._toNumbers,r=round(clamp(a(interpolate(s[0],o[0],n)),0,255),0),c=round(clamp(a(interpolate(s[1],o[1],n)),0,255),0),l=round(clamp(a(interpolate(s[2],o[2],n)),0,255),0),d=clamp(a(round(interpolate(s[3],o[3],n),v)),0,1);if(e=`rgba(${r},${c},${l},${d})`,i){const e=t._numbers;e[0]=r,e[1]=c,e[2]=l,e[3]=d}}}else if(p===valueTypes.COMPLEX){e=t._strings[0];for(let s=0,c=t._toNumbers.length;s<c;s++){const o=a(round(interpolate(t._fromNumbers[s],t._toNumbers[s],n),v)),r=t._strings[s+1];e+=`${r?o+r:o}`,i&&(t._numbers[s]=o)}}if(i&&(t._number=b),!s&&r!==compositionTypes.blend){const n=t.property;o=t.target,y?o[n]=e:d===tweenTypes.ATTRIBUTE?o.setAttribute(n,e):(c=o.style,d===tweenTypes.TRANSFORM?(o!==f&&(f=o,l=o[transformsSymbol]),l[n]=e,h=1):d===tweenTypes.CSS?c[n]=e:d===tweenTypes.CSS_VAR&&c.setProperty(n,e)),m&&(j=1)}else t._value=e}if(h&&t._renderTransforms){let e=emptyString;for(let t in l)e+=`${transformsFragmentStrings[t]}${l[t]}) `;c.transform=e,h=0}t=t._next}!n&&j&&e.onRender(e)}!n&&m&&e.onUpdate(e)}return i&&E?!n&&(i.began&&!d&&c>=a&&!p||d&&c<=minValue&&p)&&(e.onComplete(e),e.completed=!d):m&&f?v===1/0?e._startTime+=e.duration:e._currentIteration>=v-1&&(e.paused=!0,!p&&!O&&(e.completed=!0,!n&&!(i&&(d||!i.began))&&(e.onComplete(e),e._resolve(e)))):e.completed=!1,j},tick=(e,t,n,s,o)=>{const i=e._currentIteration;if(render(e,t,n,s,o),e._hasChildren){const a=e,c=a.backwards,d=s?t:a._iterationTime,u=now();let l=0,r=!0;if(!s&&a._currentIteration!==i){const e=a.iterationDuration;forEachChildren(a,t=>{if(c){const s=t.duration,o=t._offset+t._delay,i=o+s;!n&&s<=minValue&&(!o||i===e)&&t.onComplete(t)}else!t.completed&&!t.backwards&&t._currentTime<t.iterationDuration&&render(t,e,n,1,tickModes.FORCE),t.began=!1,t.completed=!1}),n||a.onLoop(a)}forEachChildren(a,e=>{const t=round((d-e._offset)*e._speed,12),i=e._fps<a._fps?e.requestTick(u):o;l+=render(e,t,n,s,i),!e.completed&&r&&(r=!1)},c),!n&&l&&a.onRender(a),r&&a._currentTime>=a.duration&&(a.paused=!0,a.completed||(a.completed=!0,n||(a.onComplete(a),a._resolve(a))))}},additive={animation:null,update:noop},addAdditiveAnimation=e=>{let t=additive.animation;return t||(t={duration:minValue,computeDeltaTime:noop,_offset:0,_delay:0,_head:null,_tail:null},additive.animation=t,additive.update=()=>{e.forEach(e=>{for(let s in e){const n=e[s],t=n._head;if(t){const o=t._valueType,s=o===valueTypes.COMPLEX||o===valueTypes.COLOR?cloneArray(t._fromNumbers):null;let i=t._fromNumber,e=n._tail;for(;e&&e!==t;){if(s)for(let t=0,n=e._numbers.length;t<n;t++)s[t]+=e._numbers[t];else i+=e._number;e=e._prevAdd}t._toNumber=i,t._toNumbers=s}}}),render(t,1,1,0,tickModes.FORCE)}),t},engineTickMethod=isBrowser?requestAnimationFrame:setImmediate,engineCancelMethod=isBrowser?cancelAnimationFrame:clearImmediate;class Engine extends Clock{constructor(e){super(e),this.useDefaultMainLoop=!0,this.pauseOnDocumentHidden=!0,this.defaults=defaults,this.paused=!!(isBrowser&&doc.hidden),this.reqId=null}update(){const e=this._currentTime=now();if(this.requestTick(e)){this.computeDeltaTime(e);const n=this._speed,s=this._fps;let t=this._head;for(;t;){const o=t._next;t.paused?(removeChild(this,t),this._hasChildren=!!this._tail,t._running=!1,t.completed&&!t._cancelled&&t.cancel()):tick(t,(e-t._startTime)*t._speed*n,0,0,t._fps<s?t.requestTick(e):tickModes.AUTO),t=o}additive.update()}}wake(){return this.useDefaultMainLoop&&!this.reqId&&!this.paused&&(this.reqId=engineTickMethod(tickEngine)),this}pause(){return this.paused=!0,killEngine()}resume(){if(!this.paused)return;return this.paused=!1,forEachChildren(this,e=>e.resetTime()),this.wake()}get speed(){return this._speed*(globals.timeScale===1?1:K)}set speed(e){this._speed=e*globals.timeScale,forEachChildren(this,e=>e.speed=e._speed)}get timeUnit(){return globals.timeScale===1?"ms":"s"}set timeUnit(e){const n=.001,s=e==="s",t=s?n:1;if(globals.timeScale!==t){globals.timeScale=t,globals.tickThreshold=200*t;const e=s?n:K;this.defaults.duration*=e,this._speed*=e}}get precision(){return globals.precision}set precision(e){globals.precision=e}}const engine=(()=>{const e=new Engine(now());return isBrowser&&(globalVersions.engine=e,doc.addEventListener("visibilitychange",()=>{if(!e.pauseOnDocumentHidden)return;doc.hidden?e.pause():e.resume()})),e})(),tickEngine=()=>{engine._head?(engine.reqId=engineTickMethod(tickEngine),engine.update()):engine.reqId=0},killEngine=()=>(engineCancelMethod(engine.reqId),engine.reqId=0,engine),parseInlineTransforms=(e,t,n)=>{const s=e.style.transform;let o;if(s){const a=e[transformsSymbol];let i;for(;i=transformsExecRgx.exec(s);){const s=i[1],e=i[2].slice(1,-1);a[s]=e,s===t&&(o=e,n&&(n[t]=e))}}return s&&!isUnd(o)?o:stringStartsWith(t,"scale")?"1":stringStartsWith(t,"rotate")||stringStartsWith(t,"skew")?"0deg":"0px"};function getNodeList(e){const t=isStr(e)?globals.root.querySelectorAll(e):e;if(t instanceof NodeList||t instanceof HTMLCollection)return t}function parseTargets(e){if(isNil(e))return[];if(isArr(e)){const n=e.flat(1/0),t=[];for(let s=0,o=n.length;s<o;s++){const e=n[s];if(!isNil(e)){const n=getNodeList(e);if(n){for(let e=0,o=n.length;e<o;e++){const s=n[e];if(!isNil(s)){let e=!1;for(let n=0,o=t.length;n<o;n++)if(t[n]===s){e=!0;break}e||t.push(s)}}}else{let n=!1;for(let s=0,o=t.length;s<o;s++)if(t[s]===e){n=!0;break}n||t.push(e)}}}return t}if(!isBrowser)return[e];const t=getNodeList(e);return t?Array.from(t):[e]}function registerTargets(e){const t=parseTargets(e),n=t.length;if(n)for(let s=0;s<n;s++){const e=t[s];if(!e[isRegisteredTargetSymbol]){e[isRegisteredTargetSymbol]=!0;const t=isSvg(e),n=e.nodeType||t;n&&(e[isDomSymbol]=!0,e[isSvgSymbol]=t,e[transformsSymbol]={})}}return t}const getPath=e=>{const n=parseTargets(e),t=n[0];if(!t||!isSvg(t))return;return t},morphTo=(e,t=.33)=>n=>{const o=getPath(e);if(!o)return;const s=n.tagName==="path",r=s?" ":",",c=n[morphPointsSymbol];c&&n.setAttribute(s?"d":"points",c);let a="",i="";if(t){const e=n.getTotalLength(),c=o.getTotalLength(),l=Math.max(Math.ceil(e*t),Math.ceil(c*t));for(let t=0;t<l;t++){const d=t/(l-1),u=n.getPointAtLength(e*d),h=o.getPointAtLength(c*d),m=s?t===0?"M":"L":"";a+=m+round(u.x,3)+r+u.y+" ",i+=m+round(h.x,3)+r+h.y+" "}}else a=n.getAttribute(s?"d":"points"),i=o.getAttribute(s?"d":"points");return n[morphPointsSymbol]=i,[a,i]},getScaleFactor=e=>{let t=1;if(e&&e.getCTM){const n=e.getCTM();if(n){const e=sqrt(n.a*n.a+n.b*n.b),s=sqrt(n.c*n.c+n.d*n.d);t=(e+s)/2}}return t},createDrawableProxy=(e,t,n)=>{const s=K,i=getComputedStyle(e),o=i.strokeLinecap,c=i.vectorEffect==="non-scaling-stroke"?e:null;let a=o;const r=new Proxy(e,{get(e,t){const n=e[t];return t===proxyTargetSymbol?e:t==="setAttribute"?(...t)=>{if(t[0]==="draw"){const h=t[1],l=h.split(" "),n=+l[0],i=+l[1],r=getScaleFactor(c),d=n*-1e3*r,u=i*s*r+d,m=s*r+(n===0&&i===1||n===1&&i===0?0:10*r)-u;if(o!=="butt"){const t=n===i?"butt":o;a!==t&&(e.style.strokeLinecap=`${t}`,a=t)}e.setAttribute("stroke-dashoffset",`${d}`),e.setAttribute("stroke-dasharray",`${u} ${m}`)}return Reflect.apply(n,e,t)}:isFnc(n)?(...t)=>Reflect.apply(n,e,t):n}});return e.getAttribute("pathLength")!==`${s}`&&(e.setAttribute("pathLength",`${s}`),r.setAttribute("draw",`${t} ${n}`)),r},createDrawable=(e,t=0,n=0)=>{const s=parseTargets(e);return s.map(e=>createDrawableProxy(e,t,n))},getPathPoint=(e,t,n=0)=>e.getPointAtLength(t+n>=1?t+n:0),getPathProgess=(e,t)=>n=>{const i=+e.getTotalLength(),o=n[isSvgSymbol],s=e.getCTM();return{from:0,to:i,modifier:n=>{if(t==="a"){const t=getPathPoint(e,n,-1),s=getPathPoint(e,n,1);return atan2(s.y-t.y,s.x-t.x)*180/PI}const i=getPathPoint(e,n,0);return t==="x"?o||!s?i.x:i.x*s.a+i.y*s.c+s.e:o||!s?i.y:i.x*s.b+i.y*s.d+s.f}}},createMotionPath=e=>{const t=getPath(e);if(!t)return;return{translateX:getPathProgess(t,"x"),translateY:getPathProgess(t,"y"),rotate:getPathProgess(t,"a")}},cssReservedProperties=["opacity","rotate","overflow","color"],isValidSVGAttribute=(e,t)=>{if(cssReservedProperties.includes(t))return!1;if(e.getAttribute(t)||t in e){if(t==="scale"){const t=e.parentNode;return t&&t.tagName==="filter"}return!0}},svg={morphTo,createMotionPath,createDrawable},rgbToRgba=e=>{const t=rgbExecRgx.exec(e)||rgbaExecRgx.exec(e),n=isUnd(t[4])?1:+t[4];return[+t[1],+t[2],+t[3],n]},hexToRgba=e=>{const n=e.length,t=n===4||n===5;return[+("0x"+e[1]+e[t?1:2]),+("0x"+e[t?2:3]+e[t?2:4]),+("0x"+e[t?3:5]+e[t?3:6]),n===5||n===9?+(+("0x"+e[t?4:7]+e[t?4:8])/255).toFixed(3):1]},hue2rgb=(e,t,n)=>(n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+(t-e)*6*n:n<1/2?t:n<2/3?e+(t-e)*(2/3-n)*6:e),hslToRgba=e=>{const n=hslExecRgx.exec(e)||hslaExecRgx.exec(e),o=+n[1]/360,s=+n[2]/100,t=+n[3]/100,c=isUnd(n[4])?1:+n[4];let i,a,r;if(s===0)i=a=r=t;else{const e=t<.5?t*(1+s):t+s-t*s,n=2*t-e;i=round(hue2rgb(n,e,o+1/3)*255,0),a=round(hue2rgb(n,e,o)*255,0),r=round(hue2rgb(n,e,o-1/3)*255,0)}return[i,a,r,c]},convertColorStringValuesToRgbaArray=e=>isRgb(e)?rgbToRgba(e):isHex(e)?hexToRgba(e):isHsl(e)?hslToRgba(e):[0,0,0,1],setValue=(e,t)=>isUnd(e)?t:e,getFunctionValue=(e,t,n,s,o)=>{if(isFnc(e)){const i=()=>{const o=e(t,n,s);return isNaN(+o)?o||0:+o};return o&&(o.func=i),i()}return e},getTweenType=(e,t)=>e[isDomSymbol]?e[isSvgSymbol]&&isValidSVGAttribute(e,t)?tweenTypes.ATTRIBUTE:validTransforms.includes(t)||shortTransforms.get(t)?tweenTypes.TRANSFORM:stringStartsWith(t,"--")?tweenTypes.CSS_VAR:t in e.style?tweenTypes.CSS:t in e?tweenTypes.OBJECT:tweenTypes.ATTRIBUTE:tweenTypes.OBJECT,getCSSValue=(e,t,n)=>{const s=e.style[t];s&&n&&(n[t]=s);const o=s||getComputedStyle(e[proxyTargetSymbol]||e).getPropertyValue(t);return o==="auto"?"0":o},getOriginalAnimatableValue=(e,t,n,s)=>{const o=isUnd(n)?getTweenType(e,t):n;return o===tweenTypes.OBJECT?e[t]||0:o===tweenTypes.ATTRIBUTE?e.getAttribute(t):o===tweenTypes.TRANSFORM?parseInlineTransforms(e,t,s):o===tweenTypes.CSS_VAR?getCSSValue(e,t,s).trimStart():getCSSValue(e,t,s)},getRelativeValue=(e,t,n)=>n==="-"?e-t:n==="+"?e+t:e*t,createDecomposedValueTargetObject=()=>({t:valueTypes.NUMBER,n:0,u:null,o:null,d:null,s:null}),decomposeRawValue=(e,t)=>{if(t.t=valueTypes.NUMBER,t.n=0,t.u=null,t.o=null,t.d=null,t.s=null,!e)return t;const o=+e;if(!isNaN(o))return t.n=o,t;let n=e;n[1]==="="&&(t.o=n[0],n=n.slice(2));const s=!n.includes(" ")&&unitsExecRgx.exec(n);if(s)return t.t=valueTypes.UNIT,t.n=+s[1],t.u=s[2],t;if(t.o)return t.n=+n,t;if(isCol(n))return t.t=valueTypes.COLOR,t.d=convertColorStringValuesToRgbaArray(n),t;const matchedNumbers=n.match(digitWithExponentRgx);return t.t=valueTypes.COMPLEX,t.d=matchedNumbers?matchedNumbers.map(Number):[],t.s=n.split(digitWithExponentRgx)||[],t},decomposeTweenValue=(e,t)=>(t.t=e._valueType,t.n=e._toNumber,t.u=e._unit,t.o=null,t.d=cloneArray(e._toNumbers),t.s=cloneArray(e._strings),t),decomposedOriginalValue=createDecomposedValueTargetObject(),lookups={_rep:new WeakMap,_add:new Map},getTweenSiblings=(e,t,n="_rep")=>{const o=lookups[n];let s=o.get(e);return s||(s={},o.set(e,s)),s[t]?s[t]:s[t]={_head:null,_tail:null}},addTweenSortMethod=(e,t)=>e._isOverridden||e._absoluteStartTime>t._absoluteStartTime,overrideTween=e=>{e._isOverlapped=1,e._isOverridden=1,e._changeDuration=minValue,e._currentTime=minValue},composeTween=(e,t)=>{const n=e._composition;if(n===compositionTypes.replace){{const s=e._absoluteStartTime;addChild(t,e,addTweenSortMethod,"_prevRep","_nextRep");const n=e._prevRep;if(n){const t=n.parent,o=n._absoluteStartTime+n._changeDuration;if(e.parent.id!==t.id&&t.iterationCount>1&&o+(t.duration-t.iterationDuration)>s){overrideTween(n);let e=n._prevRep;for(;e&&e.parent.id===t.id;)overrideTween(e),e=e._prevRep}const i=s-e._delay;if(o>i){const e=n._startTime,t=o-(e+n._updateDuration);n._changeDuration=i-t-e,n._currentTime=n._changeDuration,n._isOverlapped=1,n._changeDuration<minValue&&overrideTween(n)}let a=!0;if(forEachChildren(t,e=>{e._isOverlapped||(a=!1)}),a){const e=t.parent;if(e){let n=!0;forEachChildren(e,e=>{e!==t&&forEachChildren(e,e=>{e._isOverlapped||(n=!1)})}),n&&e.cancel()}else t.cancel()}}}}else if(n===compositionTypes.blend){const n=getTweenSiblings(e.target,e.property,"_add"),o=addAdditiveAnimation(lookups._add);let t=n._head;t||(t={...e},t._composition=compositionTypes.replace,t._updateDuration=minValue,t._startTime=0,t._numbers=cloneArray(e._fromNumbers),t._number=0,t._next=null,t._prev=null,addChild(n,t),addChild(o,t));const s=e._toNumber;if(e._fromNumber=t._fromNumber-s,e._toNumber=0,e._numbers=cloneArray(e._fromNumbers),e._number=0,t._fromNumber=s,e._toNumbers){const n=cloneArray(e._toNumbers);n&&n.forEach((n,s)=>{e._fromNumbers[s]=t._fromNumbers[s]-n,e._toNumbers[s]=0}),t._fromNumbers=n}addChild(n,e,null,"_prevAdd","_nextAdd")}return e},removeTweenSliblings=e=>{const t=e._composition;if(t!==compositionTypes.none){const n=e.target,s=e.property,o=lookups._rep,i=o.get(n),a=i[s];if(removeChild(a,e,"_prevRep","_nextRep"),t===compositionTypes.blend){const a=lookups._add,t=a.get(n);if(!t)return;const o=t[s],r=additive.animation;removeChild(o,e,"_prevAdd","_nextAdd");const i=o._head;if(i&&i===o._tail){removeChild(o,i,"_prevAdd","_nextAdd"),removeChild(r,i);let e=!0;for(let n in t)if(t[n]._head){e=!1;break}e&&a.delete(n)}}}return e},resetTimerProperties=e=>(e.paused=!0,e.began=!1,e.completed=!1,e),reviveTimer=e=>e._cancelled?(e._hasChildren?forEachChildren(e,reviveTimer):forEachChildren(e,e=>{e._composition!==compositionTypes.none&&composeTween(e,getTweenSiblings(e.target,e.property))}),e._cancelled=0,e):e;let timerId=0;class Timer extends Clock{constructor(e={},t=null,n=0){super(0);const{id:d,delay:i,duration:a,reversed:E,alternate:C,loop:x,loopDelay:O,autoplay:w,frameRate:f,playbackRate:j,onComplete:p,onLoop:y,onPause:m,onBegin:g,onBeforeUpdate:v,onUpdate:b}=e;globals.scope&&globals.scope.revertibles.push(this);const l=t?0:engine._elapsedTime,s=t?t.defaults:globals.defaults,_=isFnc(i)||isUnd(i)?s.delay:+i,h=isFnc(a)||isUnd(a)?1/0:+a,o=setValue(x,s.loop),c=setValue(O,s.loopDelay),u=o===!0||o===1/0||o<0?1/0:o+1;let r=0;if(t)r=n;else{let e=now();engine.paused&&(engine.requestTick(e),e=engine._elapsedTime),r=e-engine._startTime}this.id=isUnd(d)?++timerId:d,this.parent=t,this.duration=clampInfinity((h+c)*u-c)||minValue,this.backwards=!1,this.paused=!0,this.began=!1,this.completed=!1,this.onBegin=g||s.onBegin,this.onBeforeUpdate=v||s.onBeforeUpdate,this.onUpdate=b||s.onUpdate,this.onLoop=y||s.onLoop,this.onPause=m||s.onPause,this.onComplete=p||s.onComplete,this.iterationDuration=h,this.iterationCount=u,this._autoplay=!t&&setValue(w,s.autoplay),this._offset=r,this._delay=_,this._loopDelay=c,this._iterationTime=0,this._currentIteration=0,this._resolve=noop,this._running=!1,this._reversed=+setValue(E,s.reversed),this._reverse=this._reversed,this._cancelled=0,this._alternate=setValue(C,s.alternate),this._prev=null,this._next=null,this._elapsedTime=l,this._startTime=l,this._lastTime=l,this._fps=setValue(f,s.frameRate),this._speed=setValue(j,s.playbackRate)}get cancelled(){return!!this._cancelled}set cancelled(e){e?this.cancel():this.reset(1).play()}get currentTime(){return clamp(round(this._currentTime,globals.precision),-this._delay,this.duration)}set currentTime(e){const t=this.paused;this.pause().seek(+e),t||this.resume()}get iterationCurrentTime(){return round(this._iterationTime,globals.precision)}set iterationCurrentTime(e){this.currentTime=this.iterationDuration*this._currentIteration+e}get progress(){return clamp(round(this._currentTime/this.duration,5),0,1)}set progress(e){this.currentTime=this.duration*e}get iterationProgress(){return clamp(round(this._iterationTime/this.iterationDuration,5),0,1)}set iterationProgress(e){const t=this.iterationDuration;this.currentTime=t*this._currentIteration+t*e}get currentIteration(){return this._currentIteration}set currentIteration(e){this.currentTime=this.iterationDuration*clamp(+e,0,this.iterationCount-1)}get reversed(){return!!this._reversed}set reversed(e){e?this.reverse():this.play()}get speed(){return super.speed}set speed(e){super.speed=e,this.resetTime()}reset(e=0){return reviveTimer(this),this._reversed&&!this._reverse&&(this.reversed=!1),this._iterationTime=this.iterationDuration,tick(this,0,1,e,tickModes.FORCE),resetTimerProperties(this),this._hasChildren&&forEachChildren(this,resetTimerProperties),this}init(e=0){this.fps=this._fps,this.speed=this._speed,!e&&this._hasChildren&&tick(this,this.duration,1,e,tickModes.FORCE),this.reset(e);const t=this._autoplay;return t===!0?this.resume():t&&!isUnd(t.linked)&&t.link(this),this}resetTime(){const e=1/(this._speed*engine._speed);return this._startTime=now()-(this._currentTime+this._delay)*e,this}pause(){return this.paused?this:(this.paused=!0,this.onPause(this),this)}resume(){return this.paused?(this.paused=!1,this.duration<=minValue&&!this._hasChildren?tick(this,minValue,0,0,tickModes.FORCE):(this._running||(addChild(engine,this),engine._hasChildren=!0,this._running=!0),this.resetTime(),this._startTime-=12,engine.wake()),this):this}restart(){return this.reset(0).resume()}seek(e,t=0,n=0){reviveTimer(this),this.completed=!1;const s=this.paused;return this.paused=!0,tick(this,e+this._delay,~~t,~~n,tickModes.AUTO),s?this:this.resume()}alternate(){const t=this._reversed,e=this.iterationCount,n=this.iterationDuration,s=e===1/0?floor(maxValue/n):e;return this._reversed=+(this._alternate&&!(s%2)?t:!t),e===1/0?this.iterationProgress=this._reversed?1-this.iterationProgress:this.iterationProgress:this.seek(n*s-this._currentTime),this.resetTime(),this}play(){return this._reversed&&this.alternate(),this.resume()}reverse(){return this._reversed||this.alternate(),this.resume()}cancel(){return this._hasChildren?forEachChildren(this,e=>e.cancel(),!0):forEachChildren(this,removeTweenSliblings),this._cancelled=1,this.pause()}stretch(e){const n=this.duration,s=normalizeTime(e);if(n===s)return this;const t=e/n,o=e<=minValue;return this.duration=o?minValue:s,this.iterationDuration=o?minValue:normalizeTime(this.iterationDuration*t),this._offset*=t,this._delay*=t,this._loopDelay*=t,this}revert(){tick(this,0,1,0,tickModes.AUTO);const e=this._autoplay;return e&&e.linked&&e.linked===this&&e.revert(),this.cancel()}complete(){return this.seek(this.duration).cancel()}then(e=noop){const t=this.then,n=()=>{this.then=null,e(this),this.then=t,this._resolve=noop};return new Promise(e=>(this._resolve=()=>e(n()),this.completed&&this._resolve(),this))}}const createTimer=e=>new Timer(e,null,0).init(),none=e=>e,calcBezier=(e,t,n)=>(((1-3*n+3*t)*e+(3*n-6*t))*e+3*t)*e,binarySubdivide=(e,t,n)=>{let o=0,a=1,i,s,r=0;do s=o+(a-o)/2,i=calcBezier(s,t,n)-e,i>0?a=s:o=s;while(abs(i)>1e-7&&++r<100)return s},cubicBezier=(e=.5,t=0,n=.5,s=1)=>e===t&&n===s?none:o=>o===0||o===1?o:calcBezier(binarySubdivide(o,e,n),t,s),steps=(e=10,t)=>{const n=t?ceil:floor;return t=>n(clamp(t,0,1)*e)*(1/e)},linear=(...e)=>{const o=e.length;if(!o)return none;const s=o-1,i=e[0],a=e[s],n=[0],t=[parseNumber(i)];for(let o=1;o<s;o++){const i=e[o],a=isStr(i)?i.trim().split(" "):[i],c=a[0],r=a[1];n.push(isUnd(r)?o/s:parseNumber(r)/100),t.push(parseNumber(c))}return t.push(parseNumber(a)),n.push(1),function(s){for(let e=1,i=n.length;e<i;e++){const o=n[e];if(s<=o){const i=n[e-1],a=t[e-1];return a+(t[e]-a)*(s-i)/(o-i)}}return t[t.length-1]}},irregular=(e=10,t=1)=>{const n=[0],s=e-1;for(let e=1;e<s;e++){const i=n[e-1],o=e/s,a=(e+1)/s,r=o+(a-o)*Math.random(),c=o*(1-t)+r*t;n.push(clamp(c,i,1))}return n.push(1),linear(...n)},halfPI=PI/2,doublePI=PI*2,easeInPower=(e=1.68)=>t=>pow(t,+e),easeInFunctions={[emptyString]:easeInPower,Quad:easeInPower(2),Cubic:easeInPower(3),Quart:easeInPower(4),Quint:easeInPower(5),Sine:e=>1-cos(e*halfPI),Circ:e=>1-sqrt(1-e*e),Expo:e=>e?pow(2,10*e-10):0,Bounce:e=>{let t,n=4;for(;e<((t=pow(2,--n))-1)/11;);return 1/pow(4,3-n)-7.5625*pow((t*3-2)/22-e,2)},Back:(e=1.70158)=>t=>(+e+1)*t*t*t-+e*t*t,Elastic:(e=1,t=.3)=>{const n=clamp(+e,1,10),s=clamp(+t,minValue,2),o=s/doublePI*asin(1/n),i=doublePI/s;return e=>e===0||e===1?e:-n*pow(2,-10*(1-e))*sin((1-e-o)*i)}},easeTypes={in:e=>t=>e(t),out:e=>t=>1-e(1-t),inOut:e=>t=>t<.5?e(t*2)/2:1-e(t*-2+2)/2,outIn:e=>t=>t<.5?(1-e(1-t*2))/2:(e(t*2-1)+1)/2},parseEaseString=(e,t,n)=>{if(n[e])return n[e];if(e.indexOf("(")<=-1){const o=easeTypes[e]||e.includes("Back")||e.includes("Elastic"),s=o?t[e]():t[e];return s?n[e]=s:none}const s=e.slice(0,-1).split("("),o=t[s[0]];return o?n[e]=o(...s[1].split(",")):none},eases=(()=>{const e={linear,irregular,steps,cubicBezier};for(let t in easeTypes)for(let n in easeInFunctions){const s=easeInFunctions[n],o=easeTypes[t];e[t+n]=n===emptyString||n==="Back"||n==="Elastic"?(e,t)=>o(s(e,t)):o(s)}return e})(),JSEasesLookups={linear:none},parseEasings=e=>isFnc(e)?e:isStr(e)?parseEaseString(e,eases,JSEasesLookups):none,propertyNamesCache={},sanitizePropertyName=(e,t,n)=>{if(n===tweenTypes.TRANSFORM){const t=shortTransforms.get(e);return t||e}if(n===tweenTypes.CSS||n===tweenTypes.ATTRIBUTE&&isSvg(t)&&e in t.style){const t=propertyNamesCache[e];if(t)return t;const n=e&&toLowerCase(e);return propertyNamesCache[e]=n,n}else return e},angleUnitsMap={deg:1,rad:180/PI,turn:360},convertedValuesCache={},convertValueUnit=(e,t,n,s=!1)=>{const o=t.u,i=t.n;if(t.t===valueTypes.UNIT&&o===n)return t;const a=i+o+n,r=convertedValuesCache[a];if(!isUnd(r)&&!s)t.n=r;else{let s;if(o in angleUnitsMap)s=i*angleUnitsMap[o]/angleUnitsMap[n];else{const a=100,t=e.cloneNode(),r=e.parentNode,c=r&&r!==doc?r:doc.body;c.appendChild(t);const l=t.style;l.width=a+o;const d=t.offsetWidth||a;l.width=a+n;const u=t.offsetWidth||a,h=d/u;c.removeChild(t),s=h*i}t.n=s,convertedValuesCache[a]=s}return t.t===valueTypes.UNIT,t.u=n,t},cleanInlineStyles=e=>{if(e._hasChildren)forEachChildren(e,cleanInlineStyles,!0);else{const t=e;t.pause(),forEachChildren(t,e=>{const n=e.property,s=e.target;if(s[isDomSymbol]){const i=s.style,o=t._inlineStyles[n];if(e._tweenType===tweenTypes.TRANSFORM){{const t=s[transformsSymbol];if(isUnd(o)||o===emptyString?delete t[n]:t[n]=o,e._renderTransforms)if(Object.keys(t).length){let e=emptyString;for(let n in t)e+=transformsFragmentStrings[n]+t[n]+") ";i.transform=e}else i.removeProperty("transform")}}else isUnd(o)||o===emptyString?i.removeProperty(n):i[n]=o;t._tail===e&&t.targets.forEach(e=>{e.getAttribute&&e.getAttribute("style")===emptyString&&e.removeAttribute("style")})}})}return e},fromTargetObject=createDecomposedValueTargetObject(),toTargetObject=createDecomposedValueTargetObject(),toFunctionStore={func:null},keyframesTargetArray=[null],fastSetValuesArray=[null,null],keyObjectTarget={to:null};let tweenId=0,keyframes,key;const generateKeyframes=(e,t)=>{const n={};if(isArr(e)){const t=[].concat(...e.map(e=>Object.keys(e))).filter(isKey);for(let s=0,i=t.length;s<i;s++){const o=t[s],a=e.map(e=>{const t={};for(let n in e){const s=e[n];isKey(n)?n===o&&(t.to=s):t[n]=s}return t});n[o]=a}}else{const s=setValue(t.duration,globals.defaults.duration),o=Object.keys(e).map(t=>({o:parseFloat(t)/100,p:e[t]})).sort((e,t)=>e.o-t.o);o.forEach(e=>{const o=e.o,t=e.p;for(let e in t)if(isKey(e)){let i=n[e];i||(i=n[e]=[]);const l=o*s;let a=i.length,d=i[a-1];const r={to:t[e]};let c=0;for(let e=0;e<a;e++)c+=i[e].duration;a===1&&(r.from=d.to),t.ease&&(r.ease=t.ease),r.duration=l-(a?c:0),i.push(r)}return e});for(let s in n){const e=n[s];let t;for(let n=0,o=e.length;n<o;n++){const s=e[n],i=s.ease;s.ease=t||void 0,t=i}e[0].duration||e.shift()}}return n};class JSAnimation extends Timer{constructor(e,t,n,s,o=!1,i=0,a=0){super(t,n,s);const v=registerTargets(e),h=v.length,w=t.keyframes,f=w?mergeObjects(generateKeyframes(w,t),t):t,{delay:F,duration:M,ease:d,playbackEase:S,modifier:k,composition:g,onRender:C}=f,l=n?n.defaults:globals.defaults,b=setValue(S,l.playbackEase),y=b?parseEasings(b):null,_=!isUnd(d)&&!isUnd(d.ease),T=_?d.ease:setValue(d,y?"linear":l.ease),j=_?d.duration:setValue(M,l.duration),x=setValue(F,l.delay),O=k||l.modifier,E=isUnd(g)&&h>=K?compositionTypes.none:isUnd(g)?l.composition:g,u={},A=this._offset+(n?n._offset:0);let c=NaN,r=NaN,p=0,m=0;for(let l=0;l<h;l++){const e=v[l],t=i||l,s=a||h;let d=NaN,g=NaN;for(let i in f)if(isKey(i)){const l=getTweenType(e,i),v=sanitizePropertyName(i,e,l);let a=f[i];const C=isArr(a);if(o&&!C&&(fastSetValuesArray[0]=a,fastSetValuesArray[1]=a,a=fastSetValuesArray),C){const e=a.length,t=!isObj(a[0]);e===2&&t?(keyObjectTarget.to=a,keyframesTargetArray[0]=keyObjectTarget,keyframes=keyframesTargetArray):e>2&&t?(keyframes=[],a.forEach((e,t)=>{t?t===1?(fastSetValuesArray[1]=e,keyframes.push(fastSetValuesArray)):keyframes.push(e):fastSetValuesArray[0]=e})):keyframes=a}else keyframesTargetArray[0]=a,keyframes=keyframesTargetArray;let y=null,h=null,_=NaN,w=0,b=0;for(let z=keyframes.length;b<z;b++){const D=keyframes[b];isObj(D)?key=D:(keyObjectTarget.to=D,key=keyObjectTarget),toFunctionStore.func=null;const r=getFunctionValue(key.to,e,t,s,toFunctionStore);let i;isObj(r)&&!isUnd(r.to)?(key=r,i=r.to):i=r;const M=getFunctionValue(key.from,e,t,s),a=key.ease,L=!isUnd(a)&&!isUnd(a.ease),I=L?a.ease:a||T,B=L?a.duration:getFunctionValue(setValue(key.duration,z>1?getFunctionValue(j,e,t,s)/z:j),e,t,s),C=getFunctionValue(setValue(key.delay,b?0:x),e,t,s),F=getFunctionValue(setValue(key.composition,E),e,t,s),k=isNum(F)?F:compositionTypes[F],P=key.modifier||O,f=!isUnd(M),R=!isUnd(i),c=isArr(i),H=c||f&&R,N=h?w+C:C,g=A+N;!m&&(f||c)&&(m=1);let o=h;if(k!==compositionTypes.none){y||(y=getTweenSiblings(e,v));let t=y._head;for(;t&&!t._isOverridden&&t._absoluteStartTime<=g;)if(o=t,t=t._nextRep,t&&t._absoluteStartTime>=g)for(;t;)overrideTween(t),t=t._nextRep}if(H?(decomposeRawValue(c?getFunctionValue(i[0],e,t,s):M,fromTargetObject),decomposeRawValue(c?getFunctionValue(i[1],e,t,s,toFunctionStore):i,toTargetObject),fromTargetObject.t===valueTypes.NUMBER&&(o?o._valueType===valueTypes.UNIT&&(fromTargetObject.t=valueTypes.UNIT,fromTargetObject.u=o._unit):(decomposeRawValue(getOriginalAnimatableValue(e,v,l,u),decomposedOriginalValue),decomposedOriginalValue.t===valueTypes.UNIT&&(fromTargetObject.t=valueTypes.UNIT,fromTargetObject.u=decomposedOriginalValue.u)))):(R?decomposeRawValue(i,toTargetObject):h?decomposeTweenValue(h,toTargetObject):decomposeRawValue(n&&o&&o.parent.parent===n?o._value:getOriginalAnimatableValue(e,v,l,u),toTargetObject),f?decomposeRawValue(M,fromTargetObject):h?decomposeTweenValue(h,fromTargetObject):decomposeRawValue(n&&o&&o.parent.parent===n?o._value:getOriginalAnimatableValue(e,v,l,u),fromTargetObject)),fromTargetObject.o&&(fromTargetObject.n=getRelativeValue(o?o._toNumber:decomposeRawValue(getOriginalAnimatableValue(e,v,l,u),decomposedOriginalValue).n,fromTargetObject.n,fromTargetObject.o)),toTargetObject.o&&(toTargetObject.n=getRelativeValue(fromTargetObject.n,toTargetObject.n,toTargetObject.o)),fromTargetObject.t!==toTargetObject.t)if(fromTargetObject.t===valueTypes.COMPLEX||toTargetObject.t===valueTypes.COMPLEX){const t=fromTargetObject.t===valueTypes.COMPLEX?fromTargetObject:toTargetObject,e=fromTargetObject.t===valueTypes.COMPLEX?toTargetObject:fromTargetObject;e.t=valueTypes.COMPLEX,e.s=cloneArray(t.s),e.d=t.d.map(()=>e.n)}else if(fromTargetObject.t===valueTypes.UNIT||toTargetObject.t===valueTypes.UNIT){const t=fromTargetObject.t===valueTypes.UNIT?fromTargetObject:toTargetObject,e=fromTargetObject.t===valueTypes.UNIT?toTargetObject:fromTargetObject;e.t=valueTypes.UNIT,e.u=t.u}else if(fromTargetObject.t===valueTypes.COLOR||toTargetObject.t===valueTypes.COLOR){const t=fromTargetObject.t===valueTypes.COLOR?fromTargetObject:toTargetObject,e=fromTargetObject.t===valueTypes.COLOR?toTargetObject:fromTargetObject;e.t=valueTypes.COLOR,e.s=t.s,e.d=[0,0,0,1]}if(fromTargetObject.u!==toTargetObject.u){let t=toTargetObject.u?fromTargetObject:toTargetObject;t=convertValueUnit(e,t,toTargetObject.u?toTargetObject.u:fromTargetObject.u,!1)}if(toTargetObject.d&&fromTargetObject.d&&toTargetObject.d.length!==fromTargetObject.d.length){const t=fromTargetObject.d.length>toTargetObject.d.length?fromTargetObject:toTargetObject,e=t===fromTargetObject?toTargetObject:fromTargetObject;e.d=t.d.map((t,n)=>isUnd(e.d[n])?0:e.d[n]),e.s=cloneArray(t.s)}const S=round(+B||minValue,12),d={parent:this,id:tweenId++,property:v,target:e,_value:null,_func:toFunctionStore.func,_ease:parseEasings(I),_fromNumbers:cloneArray(fromTargetObject.d),_toNumbers:cloneArray(toTargetObject.d),_strings:cloneArray(toTargetObject.s),_fromNumber:fromTargetObject.n,_toNumber:toTargetObject.n,_numbers:cloneArray(fromTargetObject.d),_number:fromTargetObject.n,_unit:toTargetObject.u,_modifier:P,_currentTime:0,_startTime:N,_delay:+C,_updateDuration:S,_changeDuration:S,_absoluteStartTime:g,_tweenType:l,_valueType:toTargetObject.t,_composition:k,_isOverlapped:0,_isOverridden:0,_renderTransforms:0,_prevRep:null,_nextRep:null,_prevAdd:null,_nextAdd:null,_prev:null,_next:null};k!==compositionTypes.none&&composeTween(d,y),isNaN(_)&&(_=d._startTime),w=round(N+S,12),h=d,p++,addChild(this,d)}(isNaN(r)||_<r)&&(r=_),(isNaN(c)||w>c)&&(c=w),l===tweenTypes.TRANSFORM&&(d=p-b,g=p)}if(!isNaN(d)){let e=0;forEachChildren(this,t=>{e>=d&&e<g&&(t._renderTransforms=1,t._composition===compositionTypes.blend&&forEachChildren(additive.animation,e=>{e.id===t.id&&(e._renderTransforms=1)})),e++})}}h||console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`),r?(forEachChildren(this,e=>{e._startTime-e._delay||(e._delay-=r),e._startTime-=r}),c-=r):r=0,c||(c=minValue,this.iterationCount=0),this.targets=v,this.duration=c===minValue?minValue:clampInfinity((c+this._loopDelay)*this.iterationCount-this._loopDelay)||minValue,this.onRender=C||l.onRender,this._ease=y,this._delay=r,this.iterationDuration=c,this._inlineStyles=u,!this._autoplay&&m&&this.onRender(this)}stretch(e){const n=this.duration;if(n===normalizeTime(e))return this;const t=e/n;return forEachChildren(this,e=>{e._updateDuration=normalizeTime(e._updateDuration*t),e._changeDuration=normalizeTime(e._changeDuration*t),e._currentTime*=t,e._startTime*=t,e._absoluteStartTime*=t}),super.stretch(e)}refresh(){return forEachChildren(this,e=>{const t=getOriginalAnimatableValue(e.target,e.property,e._tweenType);decomposeRawValue(t,decomposedOriginalValue),e._fromNumbers=cloneArray(decomposedOriginalValue.d),e._fromNumber=decomposedOriginalValue.n,e._func&&(decomposeRawValue(e._func(),toTargetObject),e._toNumbers=cloneArray(toTargetObject.d),e._strings=cloneArray(toTargetObject.s),e._toNumber=toTargetObject.n)}),this}revert(){return super.revert(),cleanInlineStyles(this)}then(e){return super.then(e)}}const animate=(e,t)=>new JSAnimation(e,t,null,0,!1).init(),easingToLinear=(e,t=100)=>{const n=[];for(let s=0;s<=t;s++)n.push(e(s/t));return`linear(${n.join(", ")})`},WAAPIEasesLookups={in:"ease-in",out:"ease-out",inOut:"ease-in-out"},WAAPIeases=(()=>{const e={};for(let t in easeTypes)e[t]=e=>easeTypes[t](easeInPower(e));return e})(),parseWAAPIEasing=e=>{let t=WAAPIEasesLookups[e];if(t)return t;if(t="linear",isStr(e)){if(stringStartsWith(e,"linear")||stringStartsWith(e,"cubic-")||stringStartsWith(e,"steps")||stringStartsWith(e,"ease"))t=e;else if(stringStartsWith(e,"cubicB"))t=toLowerCase(e);else{const n=parseEaseString(e,WAAPIeases,WAAPIEasesLookups);isFnc(n)&&(t=n===none?"linear":easingToLinear(n))}WAAPIEasesLookups[e]=t}else if(isFnc(e)){const n=easingToLinear(e);n&&(t=n)}else e.ease&&(t=easingToLinear(e.ease));return t},transformsShorthands=["x","y","z"],commonDefaultPXProperties=["perspective","width","height","margin","padding","top","right","bottom","left","borderWidth","fontSize","borderRadius",...transformsShorthands],validIndividualTransforms=[...transformsShorthands,...validTransforms.filter(e=>["X","Y","Z"].some(t=>e.endsWith(t)))];let transformsPropertiesRegistered=isBrowser&&(isUnd(CSS)||!Object.hasOwnProperty.call(CSS,"registerProperty"));const registerTransformsProperties=()=>{if(transformsPropertiesRegistered)return;validTransforms.forEach(e=>{const o=stringStartsWith(e,"skew"),t=stringStartsWith(e,"scale"),i=stringStartsWith(e,"rotate"),n=stringStartsWith(e,"translate"),s=i||o,a=s?"<angle>":t?"<number>":n?"<length-percentage>":"*";try{CSS.registerProperty({name:"--"+e,syntax:a,inherits:!1,initialValue:n?"0px":s?"0deg":t?"1":"0"})}catch{}}),transformsPropertiesRegistered=!0},WAAPIAnimationsLookups={_head:null,_tail:null},removeWAAPIAnimation=(e,t,n)=>{let s=WAAPIAnimationsLookups._head;for(;s;){const o=s._next,i=s.$el===e,a=!t||s.property===t,r=!n||s.parent===n;if(i&&a&&r){const t=s.animation;try{t.commitStyles()}catch{}t.cancel(),removeChild(WAAPIAnimationsLookups,s);const e=s.parent;e&&(e._completed++,e.animations.length===e._completed&&(e.completed=!0,e.muteCallbacks||(e.paused=!0,e.onComplete(e),e._resolve(e))))}s=o}},addWAAPIAnimation=(e,t,n,s,o)=>{const i=t.animate(s,o),a=o.delay+ +o.duration*o.iterations;i.playbackRate=e._speed,e.paused&&i.pause(),e.duration<a&&(e.duration=a,e.controlAnimation=i),e.animations.push(i),removeWAAPIAnimation(t,n),addChild(WAAPIAnimationsLookups,{parent:e,animation:i,$el:t,property:n,_next:null,_prev:null});const r=()=>{removeWAAPIAnimation(t,n,e)};return i.onremove=r,i.onfinish=r,i},normalizeTweenValue=(e,t,n,s,o)=>{let i=getFunctionValue(t,n,s,o);return isNum(i)?commonDefaultPXProperties.includes(e)||stringStartsWith(e,"translate")?`${i}px`:stringStartsWith(e,"rotate")||stringStartsWith(e,"skew")?`${i}deg`:`${i}`:i},parseIndividualTweenValue=(e,t,n,s,o,i)=>{let a="0";const r=isUnd(s)?getComputedStyle(e)[t]:normalizeTweenValue(t,s,e,o,i);if(isUnd(n))a=isArr(s)?s.map(n=>normalizeTweenValue(t,n,e,o,i)):r;else{const s=normalizeTweenValue(t,n,e,o,i);a=[s,r]}return a};class WAAPIAnimation{constructor(e,t){globals.scope&&globals.scope.revertibles.push(this),registerTransformsProperties();const a=registerTargets(e),n=a.length;n||console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);const i=setValue(t.ease,parseWAAPIEasing(globals.defaults.ease)),l=i.ease&&i,s=setValue(t.autoplay,globals.defaults.autoplay),d=!!(s&&s.link)&&s,u=t.alternate&&t.alternate===!0,c=t.reversed&&t.reversed===!0,r=setValue(t.loop,globals.defaults.loop),p=r===!0||r===1/0?1/0:isNum(r)?r+1:1,h=u?c?"alternate-reverse":"alternate":c?"reverse":"normal",m="forwards",f=parseWAAPIEasing(i),o=globals.timeScale===1?1:K;this.targets=a,this.animations=[],this.controlAnimation=null,this.onComplete=t.onComplete||noop,this.duration=0,this.muteCallbacks=!1,this.completed=!1,this.paused=!s||d!==!1,this.reversed=c,this.autoplay=s,this._speed=setValue(t.playbackRate,globals.defaults.playbackRate),this._resolve=noop,this._completed=0,this._inlineStyles=a.map(e=>e.getAttribute("style")),a.forEach((e,s)=>{const a=e[transformsSymbol],r=validIndividualTransforms.some(e=>t.hasOwnProperty(e)),c=(l?l.duration:getFunctionValue(setValue(t.duration,globals.defaults.duration),e,s,n))*o,d=getFunctionValue(setValue(t.delay,globals.defaults.delay),e,s,n)*o,u=setValue(t.composition,"replace");for(let l in t){if(!isKey(l))continue;const g={},j={iterations:p,direction:h,fill:m,easing:f,duration:c,delay:d,composite:u},y=t[l],v=!!r&&(validTransforms.includes(l)?l:shortTransforms.get(l));let b;if(isObj(y)){{const t=y,r=setValue(t.ease,i),m=r.ease&&r,f=t.to,h=t.from;if(j.duration=(m?m.duration:getFunctionValue(setValue(t.duration,c),e,s,n))*o,j.delay=getFunctionValue(setValue(t.delay,d),e,s,n)*o,j.composite=setValue(t.composition,u),j.easing=parseWAAPIEasing(r),b=parseIndividualTweenValue(e,l,h,f,s,n),v?(g[`--${v}`]=b,a[v]=b):g[l]=parseIndividualTweenValue(e,l,h,f,s,n),addWAAPIAnimation(this,e,l,g,j),!isUnd(h))if(v){const t=`--${v}`;e.style.setProperty(t,g[t][0])}else e.style[l]=g[l][0]}}else b=isArr(y)?y.map(t=>normalizeTweenValue(l,t,e,s,n)):normalizeTweenValue(l,y,e,s,n),v?(g[`--${v}`]=b,a[v]=b):g[l]=b,addWAAPIAnimation(this,e,l,g,j)}if(r){let t=emptyString;for(let e in a)t+=`${transformsFragmentStrings[e]}var(--${e})) `;e.style.transform=t}}),d&&this.autoplay.link(this)}forEach(e){const t=isStr(e)?t=>t[e]():e;return this.animations.forEach(t),this}get speed(){return this._speed}set speed(e){this._speed=+e,this.forEach(t=>t.playbackRate=e)}get currentTime(){const e=this.controlAnimation,t=globals.timeScale;return this.completed?this.duration:e?+e.currentTime*(t===1?1:t):0}set currentTime(e){const t=e*(globals.timeScale===1?1:K);this.forEach(e=>{t>=this.duration&&e.play(),e.currentTime=t})}get progress(){return this.currentTime/this.duration}set progress(e){this.forEach(t=>t.currentTime=e*this.duration||0)}resume(){return this.paused?(this.paused=!1,this.forEach("play")):this}pause(){return this.paused?this:(this.paused=!0,this.forEach("pause"))}alternate(){return this.reversed=!this.reversed,this.forEach("reverse"),this.paused&&this.forEach("pause"),this}play(){return this.reversed&&this.alternate(),this.resume()}reverse(){return this.reversed||this.alternate(),this.resume()}seek(e,t=!1){return t&&(this.muteCallbacks=!0),e<this.duration&&(this.completed=!1),this.currentTime=e,this.muteCallbacks=!1,this.paused&&this.pause(),this}restart(){return this.completed=!1,this.seek(0,!0).resume()}commitStyles(){return this.forEach("commitStyles")}complete(){return this.seek(this.duration)}cancel(){return this.forEach("cancel"),this.pause()}revert(){return this.cancel(),this.targets.forEach((e,t)=>e.setAttribute("style",this._inlineStyles[t])),this}then(e=noop){const t=this.then,n=()=>{this.then=null,e(this),this.then=t,this._resolve=noop};return new Promise(e=>(this._resolve=()=>e(n()),this.completed&&this._resolve(),this))}}const waapi={animate:(e,t)=>new WAAPIAnimation(e,t),convertEase:easingToLinear},sync=(e=noop)=>new Timer({duration:1*globals.timeScale,onComplete:e},null,0).resume();function getTargetValue(e,t,n){const o=registerTargets(e);if(!o.length)return;const[s]=o,a=getTweenType(s,t),r=sanitizePropertyName(t,s,a);let i=getOriginalAnimatableValue(s,r);if(isUnd(n))return i;if(decomposeRawValue(i,decomposedOriginalValue),decomposedOriginalValue.t===valueTypes.NUMBER||decomposedOriginalValue.t===valueTypes.UNIT){if(n===!1)return decomposedOriginalValue.n;const e=convertValueUnit(s,decomposedOriginalValue,n,!1);return`${round(e.n,globals.precision)}${e.u}`}}const setTargetValues=(e,t)=>{if(isUnd(t))return;return t.duration=minValue,t.composition=setValue(t.composition,compositionTypes.none),new JSAnimation(e,t,null,0,!0).resume()},removeTargetsFromAnimation=(e,t,n)=>{let s=!1;return forEachChildren(t,o=>{const i=o.target;if(e.includes(i)){const a=o.property,r=o._tweenType,e=sanitizePropertyName(n,i,r);(!e||e&&e===a)&&(o.parent._tail===o&&o._tweenType===tweenTypes.TRANSFORM&&o._prev&&o._prev._tweenType===tweenTypes.TRANSFORM&&(o._prev._renderTransforms=1),removeChild(t,o),removeTweenSliblings(o),s=!0)}},!0),s},remove=(e,t,n)=>{const o=parseTargets(e),s=t||engine,a=t&&t.controlAnimation&&t;for(let e=0,t=o.length;e<t;e++){const s=o[e];removeWAAPIAnimation(s,n,a)}let i;if(s._hasChildren){let t=0;forEachChildren(s,a=>{if(!a._hasChildren)if(i=removeTargetsFromAnimation(o,a,n),i&&!a._head)a.cancel(),removeChild(s,a);else{const n=a._offset+a._delay,e=n+a.duration;e>t&&(t=e)}a._head?remove(e,a,n):a._hasChildren=!1},!0),isUnd(s.iterationDuration)||(s.iterationDuration=t)}else i=removeTargetsFromAnimation(o,s,n);return i&&!s._head&&(s._hasChildren=!1,s.cancel&&s.cancel()),o},random=(e,t,n)=>{const s=10**(n||0);return floor((Math.random()*(t-e+1/s)+e)*s)/s},randomPick=e=>e[random(0,e.length-1)],shuffle=e=>{let t=e.length,s,n;for(;t;)n=random(0,--t),s=e[t],e[t]=e[n],e[n]=s;return e},roundPad=(e,t)=>(+e).toFixed(t),padStart=(e,t,n)=>`${e}`.padStart(t,n),padEnd=(e,t,n)=>`${e}`.padEnd(t,n),wrap=(e,t,n)=>((e-t)%(n-t)+(n-t))%(n-t)+t,mapRange=(e,t,n,s,o)=>s+(e-t)/(n-t)*(o-s),degToRad=e=>e*PI/180,radToDeg=e=>e*180/PI,lerp=(e,t,n,s)=>{let o=K/globals.defaults.frameRate;if(s!==!1){const e=s||engine._hasChildren&&engine;e&&e.deltaTime&&(o=e.deltaTime)}const i=1-Math.exp(-n*o*.1);return n?n===1?t:(1-i)*e+i*t:e},curry=(e,t=0)=>(...n)=>t?t=>e(...n,t):t=>e(t,...n),chain=e=>(...t)=>{const n=e(...t);return new Proxy(noop,{apply:(e,t,[s])=>n(s),get:(e,t)=>chain((...e)=>{const s=utils[t](...e);return e=>s(n(e))})})},makeChainable=(e,t=0)=>(...n)=>(n.length<e.length?chain(curry(e,t)):e)(...n),utils={$:registerTargets,get:getTargetValue,set:setTargetValues,remove,cleanInlineStyles,random,randomPick,shuffle,lerp,sync,clamp:makeChainable(clamp),round:makeChainable(round),snap:makeChainable(snap),wrap:makeChainable(wrap),interpolate:makeChainable(interpolate,1),mapRange:makeChainable(mapRange),roundPad:makeChainable(roundPad),padStart:makeChainable(padStart),padEnd:makeChainable(padEnd),degToRad:makeChainable(degToRad),radToDeg:makeChainable(radToDeg)},getPrevChildOffset=(e,t)=>{if(stringStartsWith(t,"<")){const o=t[1]==="<",n=e._tail,s=n?n._offset+n._delay:0;return o?s:s+n.duration}},parseTimelinePosition=(e,t)=>{let n=e.iterationDuration;if(n===minValue&&(n=0),isUnd(t))return n;if(isNum(+t))return+t;const s=t,o=e?e.labels:null,i=!isNil(o),a=getPrevChildOffset(e,s),r=!isUnd(a),c=relativeValuesExecRgx.exec(s);if(c){const t=c[0],e=s.split(t),l=i&&e[0]?o[e[0]]:n,d=r?a:i?l:n,u=+e[1];return getRelativeValue(d,u,t[0])}return r?a:i&&!isUnd(o[s])?o[s]:n};function getTimelineTotalDuration(e){return clampInfinity((e.iterationDuration+e._loopDelay)*e.iterationCount-e._loopDelay)||minValue}function addTlChild(e,t,n,s,o,i){const c=isNum(e.duration)&&e.duration<=minValue,a=c?n-minValue:n;tick(t,a,1,1,tickModes.AUTO);const r=s?new JSAnimation(s,e,t,a,!1,o,i):new Timer(e,t,a);return r.init(1),addChild(t,r),forEachChildren(t,e=>{const s=e._offset+e._delay,n=s+e.duration;n>t.iterationDuration&&(t.iterationDuration=n)}),t.duration=getTimelineTotalDuration(t),t}class Timeline extends Timer{constructor(e={}){super(e,null,0),this.duration=0,this.labels={};const n=e.defaults,t=globals.defaults;this.defaults=n?mergeObjects(n,t):t,this.onRender=e.onRender||t.onRender;const s=setValue(e.playbackEase,t.playbackEase);this._ease=s?parseEasings(s):null,this.iterationDuration=0}add(e,t,n){const s=isObj(t),o=isObj(e);if(s||o){if(this._hasChildren=!0,s){const s=t;if(isFnc(n)){const r=n,o=parseTargets(e),c=this.duration,l=this.iterationDuration,i=s.id;let t=0;const a=o.length;o.forEach(e=>{const n={...s};this.duration=c,this.iterationDuration=l,isUnd(i)||(n.id=i+"-"+t),addTlChild(n,this,r(e,t,a,this),e,t,a),t++})}else addTlChild(s,this,parseTimelinePosition(this,n),e)}else addTlChild(e,this,parseTimelinePosition(this,t));return this.init(1)}}sync(e,t){if(isUnd(e)||e&&isUnd(e.pause))return this;e.pause();const n=+(e.effect?e.effect.getTiming().duration:e.duration);return this.add(e,{currentTime:[0,n],duration:n,ease:"linear"},t)}set(e,t,n){return isUnd(t)?this:(t.duration=minValue,t.composition=compositionTypes.replace,this.add(e,t,n))}call(e,t){return isUnd(e)||e&&!isFnc(e)?this:this.add({duration:0,onComplete:()=>e(this)},t)}label(e,t){return isUnd(e)||e&&!isStr(e)?this:(this.labels[e]=parseTimelinePosition(this,t),this)}remove(e,t){return remove(e,this,t),this}stretch(e){const t=this.duration;if(t===normalizeTime(e))return this;const n=e/t,s=this.labels;forEachChildren(this,e=>e.stretch(e.duration*n));for(let e in s)s[e]*=n;return super.stretch(e)}refresh(){return forEachChildren(this,e=>{e.refresh&&e.refresh()}),this}revert(){return super.revert(),forEachChildren(this,e=>e.revert,!0),cleanInlineStyles(this)}then(e){return super.then(e)}}const createTimeline=e=>new Timeline(e).init();class Animatable{constructor(e,t){globals.scope&&globals.scope.revertibles.push(this);const s={},n={};if(this.targets=[],this.animations={},isUnd(e)||isUnd(t))return;for(let e in t){const o=t[e];isKey(e)?n[e]=o:s[e]=o}for(let o in n){const i=n[o],l=isObj(i);let a={},r="+=0";if(l){const e=i.unit;isStr(e)&&(r+=e)}else a.duration=i;a[o]=l?mergeObjects({to:r},i):r;const c=mergeObjects(s,a);c.composition=compositionTypes.replace,c.autoplay=!1;const t=this.animations[o]=new JSAnimation(e,c,null,0,!1).init();this.targets.length||this.targets.push(...t.targets),this[o]=(e,n,s)=>{const o=t._head;if(isUnd(e)&&o){const e=o._numbers;return e&&e.length?e:o._modifier(o._number)}else return forEachChildren(t,t=>{if(isArr(e))for(let n=0,s=e.length;n<s;n++)isUnd(t._numbers[n])||(t._fromNumbers[n]=t._modifier(t._numbers[n]),t._toNumbers[n]=e[n]);else t._fromNumber=t._modifier(t._number),t._toNumber=e;isUnd(s)||(t._ease=parseEasings(s)),t._currentTime=0}),isUnd(n)||t.stretch(n),t.reset(1).resume(),this}}}revert(){for(let e in this.animations)this[e]=noop,this.animations[e].revert();return this.animations={},this.targets.length=0,this}}const createAnimatable=(e,t)=>new Animatable(e,t);class Spring{constructor(e={}){this.timeStep=.02,this.restThreshold=5e-4,this.restDuration=200,this.maxDuration=6e4,this.maxRestSteps=this.restDuration/this.timeStep/K,this.maxIterations=this.maxDuration/this.timeStep/K,this.m=clamp(setValue(e.mass,1),0,K),this.s=clamp(setValue(e.stiffness,100),1,K),this.d=clamp(setValue(e.damping,10),.1,K),this.v=clamp(setValue(e.velocity,0),-1e3,K),this.w0=0,this.zeta=0,this.wd=0,this.b=0,this.solverDuration=0,this.duration=0,this.compute(),this.ease=e=>e===0||e===1?e:this.solve(e*this.solverDuration)}solve(e){const{zeta:n,w0:s,wd:o,b:i}=this;let t=e;return n<1?t=exp(-t*n*s)*(1*cos(o*t)+i*sin(o*t)):t=(1+i*t)*exp(-t*s),1-t}compute(){const{maxRestSteps:l,maxIterations:m,restThreshold:h,timeStep:d,m:a,d:c,s:o,v:i}=this,t=this.w0=clamp(sqrt(o/a),minValue,K),e=this.zeta=c/(2*sqrt(o*a)),u=this.wd=e<1?t*sqrt(1-e*e):0;this.b=e<1?(e*t+-i)/u:-i+t;let s=0,n=0,r=0;for(;n<l&&r<m;)abs(1-this.solve(s))<h?n++:n=0,this.solverDuration=s,s+=d,r++;this.duration=round(this.solverDuration*K,0)*globals.timeScale}get mass(){return this.m}set mass(e){this.m=clamp(setValue(e,1),0,K),this.compute()}get stiffness(){return this.s}set stiffness(e){this.s=clamp(setValue(e,100),1,K),this.compute()}get damping(){return this.d}set damping(e){this.d=clamp(setValue(e,10),.1,K),this.compute()}get velocity(){return this.v}set velocity(e){this.v=clamp(setValue(e,0),-1e3,K),this.compute()}}const createSpring=e=>new Spring(e),preventDefault=e=>{e.cancelable&&e.preventDefault()};class DOMProxy{constructor(e){this.el=e,this.zIndex=0,this.parentElement=null,this.classList={add:noop,remove:noop}}get x(){return this.el.x||0}set x(e){this.el.x=e}get y(){return this.el.y||0}set y(e){this.el.y=e}get width(){return this.el.width||0}set width(e){this.el.width=e}get height(){return this.el.height||0}set height(e){this.el.height=e}getBoundingClientRect(){return{top:this.y,right:this.x,bottom:this.y+this.height,left:this.x+this.width}}}class Transforms{constructor(e){this.$el=e,this.inlineTransforms=[],this.point=new DOMPoint,this.inversedMatrix=this.getMatrix().inverse()}normalizePoint(e,t){return this.point.x=e,this.point.y=t,this.point.matrixTransform(this.inversedMatrix)}traverseUp(e){let t=this.$el.parentElement,n=0;for(;t&&t!==doc;)e(t,n),t=t.parentElement,n++}getMatrix(){const e=new DOMMatrix;return this.traverseUp(t=>{const n=getComputedStyle(t).transform;if(n){const t=new DOMMatrix(n);e.preMultiplySelf(t)}}),e}remove(){this.traverseUp((e,t)=>{this.inlineTransforms[t]=e.style.transform,e.style.transform="none"})}revert(){this.traverseUp((e,t)=>{const n=this.inlineTransforms[t];n===""?e.style.removeProperty("transform"):e.style.transform=n})}}const parseDraggableFunctionParameter=(e,t)=>e&&isFnc(e)?e(t):e;let zIndex=0;class Draggable{constructor(e,t={}){if(!e)return;globals.scope&&globals.scope.revertibles.push(this);const n=t.x,s=t.y,d=t.trigger,u=t.modifier,i=t.releaseEase,h=i&&parseEasings(i),l=!isUnd(i)&&!isUnd(i.ease),a=isObj(n)&&!isUnd(n.mapTo)?n.mapTo:"translateX",r=isObj(s)&&!isUnd(s.mapTo)?s.mapTo:"translateY",c=parseDraggableFunctionParameter(t.container,this);this.containerArray=isArr(c)?c:null,this.$container=c&&!this.containerArray?parseTargets(c)[0]:doc.body,this.useWin=this.$container===doc.body,this.$scrollContainer=this.useWin?win:this.$container,this.$target=isObj(e)?new DOMProxy(e):parseTargets(e)[0],this.$trigger=parseTargets(d||e)[0],this.fixed=getTargetValue(this.$target,"position")==="fixed",this.isFinePointer=!0,this.containerPadding=[0,0,0,0],this.containerFriction=0,this.releaseContainerFriction=0,this.snapX=0,this.snapY=0,this.scrollSpeed=0,this.scrollThreshold=0,this.dragSpeed=0,this.maxVelocity=0,this.minVelocity=0,this.velocityMultiplier=0,this.cursor=!1,this.releaseXSpring=l?i:createSpring({mass:setValue(t.releaseMass,1),stiffness:setValue(t.releaseStiffness,80),damping:setValue(t.releaseDamping,20)}),this.releaseYSpring=l?i:createSpring({mass:setValue(t.releaseMass,1),stiffness:setValue(t.releaseStiffness,80),damping:setValue(t.releaseDamping,20)}),this.releaseEase=h||eases.outQuint,this.hasReleaseSpring=l,this.onGrab=t.onGrab||noop,this.onDrag=t.onDrag||noop,this.onRelease=t.onRelease||noop,this.onUpdate=t.onUpdate||noop,this.onSettle=t.onSettle||noop,this.onSnap=t.onSnap||noop,this.onResize=t.onResize||noop,this.onAfterResize=t.onAfterResize||noop,this.disabled=[0,0];const o={};if(u&&(o.modifier=u),isUnd(n)||n===!0)o[a]=0;else if(isObj(n)){const e=n,t={};e.modifier&&(t.modifier=e.modifier),e.composition&&(t.composition=e.composition),o[a]=t}else n===!1&&(o[a]=0,this.disabled[0]=1);if(isUnd(s)||s===!0)o[r]=0;else if(isObj(s)){const e=s,t={};e.modifier&&(t.modifier=e.modifier),e.composition&&(t.composition=e.composition),o[r]=t}else s===!1&&(o[r]=0,this.disabled[1]=1);this.animate=new Animatable(this.$target,o),this.xProp=a,this.yProp=r,this.destX=0,this.destY=0,this.deltaX=0,this.deltaY=0,this.scroll={x:0,y:0},this.coords=[this.x,this.y,0,0],this.snapped=[0,0],this.pointer=[0,0,0,0,0,0,0,0],this.scrollView=[0,0],this.dragArea=[0,0,0,0],this.containerBounds=[-1e12,maxValue,maxValue,-1e12],this.scrollBounds=[0,0,0,0],this.targetBounds=[0,0,0,0],this.window=[0,0],this.velocityStack=[0,0,0],this.velocityStackIndex=0,this.velocityTime=now(),this.velocity=0,this.angle=0,this.cursorStyles=null,this.triggerStyles=null,this.bodyStyles=null,this.targetStyles=null,this.touchActionStyles=null,this.transforms=new Transforms(this.$target),this.overshootCoords={x:0,y:0},this.overshootXTicker=new Timer({autoplay:!1},null,0).init(),this.overshootYTicker=new Timer({autoplay:!1},null,0).init(),this.updateTicker=new Timer({autoplay:!1},null,0).init(),this.overshootXTicker.onUpdate=()=>{if(this.disabled[0])return;this.updated=!0,this.manual=!0,this.animate[this.xProp](this.overshootCoords.x,0)},this.overshootXTicker.onComplete=()=>{if(this.disabled[0])return;this.manual=!1,this.animate[this.xProp](this.overshootCoords.x,0)},this.overshootYTicker.onUpdate=()=>{if(this.disabled[1])return;this.updated=!0,this.manual=!0,this.animate[this.yProp](this.overshootCoords.y,0)},this.overshootYTicker.onComplete=()=>{if(this.disabled[1])return;this.manual=!1,this.animate[this.yProp](this.overshootCoords.y,0)},this.updateTicker.onUpdate=()=>this.update(),this.contained=!isUnd(c),this.manual=!1,this.grabbed=!1,this.dragged=!1,this.updated=!1,this.released=!1,this.canScroll=!1,this.enabled=!1,this.initialized=!1,this.activeProp=this.disabled[1]?a:r,this.animate.animations[this.activeProp].onRender=()=>{const n=this.updated,i=this.grabbed&&n,a=!i&&this.released,s=this.x,o=this.y,e=s-this.coords[2],t=o-this.coords[3];this.deltaX=e,this.deltaY=t,this.coords[2]=s,this.coords[3]=o,n&&this.onUpdate(this),a?(this.computeVelocity(e,t),this.angle=atan2(t,e)):this.updated=!1},this.animate.animations[this.activeProp].onComplete=()=>{!this.grabbed&&this.released&&(this.released=!1),this.manual||(this.deltaX=0,this.deltaY=0,this.velocity=0,this.velocityStack[0]=0,this.velocityStack[1]=0,this.velocityStack[2]=0,this.velocityStackIndex=0,this.onSettle(this))},this.resizeTicker=new Timer({autoplay:!1,duration:150*globals.timeScale,onComplete:()=>{this.onResize(this),this.refresh(),this.onAfterResize(this)}}).init(),this.parameters=t,this.resizeObserver=new ResizeObserver(()=>{this.initialized?this.resizeTicker.restart():this.initialized=!0}),this.enable(),this.refresh(),this.resizeObserver.observe(this.$container),isObj(e)||this.resizeObserver.observe(this.$target)}computeVelocity(e,t){const r=this.velocityTime,s=now(),o=s-r;if(o<17)return this.velocity;this.velocityTime=s;const n=this.velocityStack,c=this.velocityMultiplier,l=this.minVelocity,d=this.maxVelocity,i=this.velocityStackIndex;n[i]=round(clamp(sqrt(e*e+t*t)/o*c,l,d),5);const a=max(n[0],n[1],n[2]);return this.velocity=a,this.velocityStackIndex=(i+1)%3,a}setX(e,t=!1){if(this.disabled[0])return;const n=round(e,5);return this.overshootXTicker.pause(),this.manual=!0,this.updated=!t,this.destX=n,this.snapped[0]=snap(n,this.snapX),this.animate[this.xProp](n,0),this.manual=!1,this}setY(e,t=!1){if(this.disabled[1])return;const n=round(e,5);return this.overshootYTicker.pause(),this.manual=!0,this.updated=!t,this.destY=n,this.snapped[1]=snap(n,this.snapY),this.animate[this.yProp](n,0),this.manual=!1,this}get x(){return round(this.animate[this.xProp](),globals.precision)}set x(e){this.setX(e,!1)}get y(){return round(this.animate[this.yProp](),globals.precision)}set y(e){this.setY(e,!1)}get progressX(){return mapRange(this.x,this.containerBounds[3],this.containerBounds[1],0,1)}set progressX(e){this.setX(mapRange(e,0,1,this.containerBounds[3],this.containerBounds[1]),!1)}get progressY(){return mapRange(this.y,this.containerBounds[0],this.containerBounds[2],0,1)}set progressY(e){this.setY(mapRange(e,0,1,this.containerBounds[0],this.containerBounds[2]),!1)}updateScrollCoords(){const t=round(this.useWin?win.scrollX:this.$container.scrollLeft,0),n=round(this.useWin?win.scrollY:this.$container.scrollTop,0),[s,o,i,a]=this.containerPadding,e=this.scrollThreshold;this.scroll.x=t,this.scroll.y=n,this.scrollBounds[0]=n-this.targetBounds[0]+s-e,this.scrollBounds[1]=t-this.targetBounds[1]-o+e,this.scrollBounds[2]=n-this.targetBounds[2]-i+e,this.scrollBounds[3]=t-this.targetBounds[3]+a-e}updateBoundingValues(){const t=this.$container,y=this.x,_=this.y,O=this.coords[2],w=this.coords[3];this.coords[2]=0,this.coords[3]=0,this.setX(0,!0),this.setY(0,!0),this.transforms.remove();const n=this.window[0]=win.innerWidth,s=this.window[1]=win.innerHeight,e=this.useWin,a=t.scrollWidth,i=t.scrollHeight,o=this.fixed,v=t.getBoundingClientRect(),[r,m,f,p]=this.containerPadding;this.dragArea[0]=e?0:v.left,this.dragArea[1]=e?0:v.top,this.scrollView[0]=e?clamp(a,n,a):a,this.scrollView[1]=e?clamp(i,s,i):i,this.updateScrollCoords();const{width:g,height:h,left:u,top:d,right:c,bottom:l}=t.getBoundingClientRect();this.dragArea[2]=round(e?clamp(g,n,n):g,0),this.dragArea[3]=round(e?clamp(h,s,s):h,0);const b=getTargetValue(t,"overflow"),j=b==="visible",x=b==="hidden";if(this.canScroll=!o&&this.contained&&(t===doc.body&&j||!x&&!j)&&(a>this.dragArea[2]+p-m||i>this.dragArea[3]+r-f)&&(!this.containerArray||this.containerArray&&!isArr(this.containerArray)),this.contained){const v=this.scroll.x,b=this.scroll.y,a=this.canScroll,i=this.$target.getBoundingClientRect(),j=a?e?0:t.scrollLeft:0,y=a?e?0:t.scrollTop:0,_=a?this.scrollView[0]-j-g:0,w=a?this.scrollView[1]-y-h:0;this.targetBounds[0]=round(i.top+b-(e?0:d),0),this.targetBounds[1]=round(i.right+v-(e?n:c),0),this.targetBounds[2]=round(i.bottom+b-(e?s:l),0),this.targetBounds[3]=round(i.left+v-(e?0:u),0),this.containerArray?(this.containerBounds[0]=this.containerArray[0]+r,this.containerBounds[1]=this.containerArray[1]-m,this.containerBounds[2]=this.containerArray[2]-f,this.containerBounds[3]=this.containerArray[3]+p):(this.containerBounds[0]=-round(i.top-(o?clamp(d,0,s):d)+y-r,0),this.containerBounds[1]=-round(i.right-(o?clamp(c,0,n):c)-_+m,0),this.containerBounds[2]=-round(i.bottom-(o?clamp(l,0,s):l)-w+f,0),this.containerBounds[3]=-round(i.left-(o?clamp(u,0,n):u)+j-p,0))}this.transforms.revert(),this.coords[2]=O,this.coords[3]=w,this.setX(y,!0),this.setY(_,!0)}isOutOfBounds(e,t,n){if(!this.contained)return 0;const[r,c,l,d]=e,[i,a]=this.disabled,s=!i&&t<d||!i&&t>c,o=!a&&n<r||!a&&n>l;return s&&!o?1:!s&&o?2:s&&o?3:0}refresh(){const e=this.parameters,a=e.x,o=e.y,n=parseDraggableFunctionParameter(e.container,this),t=parseDraggableFunctionParameter(e.containerPadding,this)||0,r=isArr(t)?t:[t,t,t,t],c=this.x,l=this.y,i=parseDraggableFunctionParameter(e.cursor,this),s={onHover:"grab",onGrab:"grabbing"};if(i){const{onHover:e,onGrab:t}=i;e&&(s.onHover=e),t&&(s.onGrab=t)}this.containerArray=isArr(n)?n:null,this.$container=n&&!this.containerArray?parseTargets(n)[0]:doc.body,this.useWin=this.$container===doc.body,this.$scrollContainer=this.useWin?win:this.$container,this.isFinePointer=matchMedia("(pointer:fine)").matches,this.containerPadding=setValue(r,[0,0,0,0]),this.containerFriction=clamp(setValue(parseDraggableFunctionParameter(e.containerFriction,this),.8),0,1),this.releaseContainerFriction=clamp(setValue(parseDraggableFunctionParameter(e.releaseContainerFriction,this),this.containerFriction),0,1),this.snapX=parseDraggableFunctionParameter(isObj(a)&&!isUnd(a.snap)?a.snap:e.snap,this),this.snapY=parseDraggableFunctionParameter(isObj(o)&&!isUnd(o.snap)?o.snap:e.snap,this),this.scrollSpeed=setValue(parseDraggableFunctionParameter(e.scrollSpeed,this),1.5),this.scrollThreshold=setValue(parseDraggableFunctionParameter(e.scrollThreshold,this),20),this.dragSpeed=setValue(parseDraggableFunctionParameter(e.dragSpeed,this),1),this.minVelocity=setValue(parseDraggableFunctionParameter(e.minVelocity,this),0),this.maxVelocity=setValue(parseDraggableFunctionParameter(e.maxVelocity,this),50),this.velocityMultiplier=setValue(parseDraggableFunctionParameter(e.velocityMultiplier,this),1),this.cursor=i!==!1&&s,this.updateBoundingValues();const[d,u,h,m]=this.containerBounds;this.setX(clamp(c,m,u),!0),this.setY(clamp(l,d,h),!0)}update(){if(this.updateScrollCoords(),this.canScroll){const[j,k,E,C]=this.containerPadding,[a,l]=this.scrollView,x=this.dragArea[2],b=this.dragArea[3],e=this.scroll.x,s=this.scroll.y,i=this.$container.scrollWidth,o=this.$container.scrollHeight,h=this.useWin?clamp(i,this.window[0],i):i,m=this.useWin?clamp(o,this.window[1],o):o,f=a-h,p=l-m;this.dragged&&f>0&&(this.coords[0]-=f,this.scrollView[0]=h),this.dragged&&p>0&&(this.coords[1]-=p,this.scrollView[1]=m);const n=this.scrollSpeed*10,t=this.scrollThreshold,[d,r]=this.coords,[y,_,w,O]=this.scrollBounds,c=round(clamp((r-y+j)/t,-1,0)*n,0),u=round(clamp((d-_-k)/t,0,1)*n,0),g=round(clamp((r-w-E)/t,0,1)*n,0),v=round(clamp((d-O+C)/t,-1,0)*n,0);if(c||g||v||u){const[o,i]=this.disabled;let t=e,n=s;o||(t=round(clamp(e+(v||u),0,a-x),0),this.coords[0]-=e-t),i||(n=round(clamp(s+(c||g),0,l-b),0),this.coords[1]-=s-n),this.useWin?this.$scrollContainer.scrollBy(-(e-t),-(s-n)):this.$scrollContainer.scrollTo(t,n)}}const[c,i,a,r]=this.containerBounds,[n,s,f,u,l,d]=this.pointer;this.coords[0]+=(n-l)*this.dragSpeed,this.coords[1]+=(s-d)*this.dragSpeed,this.pointer[4]=n,this.pointer[5]=s;const[e,t]=this.coords,[h,m]=this.snapped,o=(1-this.containerFriction)*this.dragSpeed;this.setX(e>i?i+(e-i)*o:e<r?r+(e-r)*o:e,!1),this.setY(t>a?a+(t-a)*o:t<c?c+(t-c)*o:t,!1),this.computeVelocity(n-l,s-d),this.angle=atan2(s-u,n-f);const[p,g]=this.snapped;(p!==h&&this.snapX||g!==m&&this.snapY)&&this.onSnap(this)}stop(){this.updateTicker.pause(),this.overshootXTicker.pause(),this.overshootYTicker.pause();for(let e in this.animate.animations)this.animate.animations[e].pause();return remove(this,null,"x"),remove(this,null,"y"),remove(this,null,"progressX"),remove(this,null,"progressY"),remove(this.scroll),remove(this.overshootCoords),this}scrollInView(e,t=0,n=eases.inOutQuad){this.updateScrollCoords();const o=this.destX,i=this.destY,s=this.scroll,a=this.scrollBounds,r=this.canScroll;if(!this.containerArray&&this.isOutOfBounds(a,o,i)){const[h,m,f,p]=a,c=round(clamp(i-h,-1e12,0),0),l=round(clamp(o-m,0,maxValue),0),d=round(clamp(i-f,0,maxValue),0),u=round(clamp(o-p,-1e12,0),0);new JSAnimation(s,{x:round(s.x+(u?u-t:l?l+t:0),0),y:round(s.y+(c?c-t:d?d+t:0),0),duration:isUnd(e)?350*globals.timeScale:e,ease:n,onUpdate:()=>{this.canScroll=!1,this.$scrollContainer.scrollTo(s.x,s.y)}}).init().then(()=>{this.canScroll=r})}return this}handleHover(){this.isFinePointer&&this.cursor&&!this.cursorStyles&&(this.cursorStyles=setTargetValues(this.$trigger,{cursor:this.cursor.onHover}))}animateInView(e,t=0,n=eases.inOutQuad){this.stop(),this.updateBoundingValues();const o=this.x,i=this.y,[d,u,h,m]=this.containerPadding,a=this.scroll.y-this.targetBounds[0]+d+t,r=this.scroll.x-this.targetBounds[1]-u-t,c=this.scroll.y-this.targetBounds[2]-h-t,l=this.scroll.x-this.targetBounds[3]+m+t,s=this.isOutOfBounds([a,r,c,l],o,i);if(s){const[d,u]=this.disabled,h=clamp(snap(o,this.snapX),l,r),m=clamp(snap(i,this.snapY),a,c),t=isUnd(e)?350*globals.timeScale:e;!d&&(s===1||s===3)&&this.animate[this.xProp](h,t,n),!u&&(s===2||s===3)&&this.animate[this.yProp](m,t,n)}return this}handleDown(e){const h=e.target;if(this.grabbed||h.type==="range")return;e.stopPropagation(),this.grabbed=!0,this.released=!1,this.stop(),this.updateBoundingValues();const o=e.changedTouches,f=o?o[0].clientX:e.clientX,m=o?o[0].clientY:e.clientY,{x:i,y:a}=this.transforms.normalizePoint(f,m),[d,c,l,r]=this.containerBounds,t=(1-this.containerFriction)*this.dragSpeed,s=this.x,n=this.y;this.coords[0]=this.coords[2]=t?s>c?c+(s-c)/t:s<r?r+(s-r)/t:s:s,this.coords[1]=this.coords[3]=t?n>l?l+(n-l)/t:n<d?d+(n-d)/t:n:n,this.pointer[0]=i,this.pointer[1]=a,this.pointer[2]=i,this.pointer[3]=a,this.pointer[4]=i,this.pointer[5]=a,this.pointer[6]=i,this.pointer[7]=a,this.deltaX=0,this.deltaY=0,this.velocity=0,this.velocityStack[0]=0,this.velocityStack[1]=0,this.velocityStack[2]=0,this.velocityStackIndex=0,this.angle=0,this.targetStyles&&(this.targetStyles.revert(),this.targetStyles=null);const u=getTargetValue(this.$target,"zIndex",!1);zIndex=(u>zIndex?u:zIndex)+1,this.targetStyles=setTargetValues(this.$target,{zIndex}),this.triggerStyles&&(this.triggerStyles.revert(),this.triggerStyles=null),this.cursorStyles&&(this.cursorStyles.revert(),this.cursorStyles=null),this.isFinePointer&&this.cursor&&(this.bodyStyles=setTargetValues(doc.body,{cursor:this.cursor.onGrab})),this.scrollInView(100,0,eases.out(3)),this.onGrab(this),doc.addEventListener("touchmove",this),doc.addEventListener("touchend",this),doc.addEventListener("touchcancel",this),doc.addEventListener("mousemove",this),doc.addEventListener("mouseup",this),doc.addEventListener("selectstart",this)}handleMove(e){if(!this.grabbed)return;const o=e.changedTouches,l=o?o[0].clientX:e.clientX,d=o?o[0].clientY:e.clientY,{x:t,y:n}=this.transforms.normalizePoint(l,d),u=t-this.pointer[6],i=n-this.pointer[7];let s=e.target,a=!1,r=!1,c=!1;for(;o&&s&&s!==this.$trigger;){const e=getTargetValue(s,"overflow-y");if(e!=="hidden"&&e!=="visible"){const{scrollTop:e,scrollHeight:t,clientHeight:n}=s;if(t>n){c=!0,a=e<=3,r=e>=t-n-3;break}}s=s.parentNode}c&&(!a&&!r||a&&i<0||r&&i>0)?(this.pointer[0]=t,this.pointer[1]=n,this.pointer[2]=t,this.pointer[3]=n,this.pointer[4]=t,this.pointer[5]=n,this.pointer[6]=t,this.pointer[7]=n):(preventDefault(e),this.triggerStyles||(this.triggerStyles=setTargetValues(this.$trigger,{pointerEvents:"none"})),this.$trigger.addEventListener("touchstart",preventDefault,{passive:!1}),this.$trigger.addEventListener("touchmove",preventDefault,{passive:!1}),this.$trigger.addEventListener("touchend",preventDefault),(!this.disabled[0]&&abs(u)>3||!this.disabled[1]&&abs(i)>3)&&(this.updateTicker.resume(),this.pointer[2]=this.pointer[0],this.pointer[3]=this.pointer[1],this.pointer[0]=t,this.pointer[1]=n,this.dragged=!0,this.released=!1,this.onDrag(this)))}handleUp(){if(!this.grabbed)return;this.updateTicker.pause(),this.triggerStyles&&(this.triggerStyles.revert(),this.triggerStyles=null),this.bodyStyles&&(this.bodyStyles.revert(),this.bodyStyles=null);const[b,y]=this.disabled,[M,O,z,D,F,N]=this.pointer,[u,l,d,m]=this.containerBounds,[R,L]=this.snapped,x=this.releaseXSpring,k=this.releaseYSpring,f=this.releaseEase,n=this.hasReleaseSpring,g=this.overshootCoords,c=this.x,i=this.y,_=this.computeVelocity(M-F,O-N),E=this.angle=atan2(O-D,M-z),v=_*150,h=(1-this.releaseContainerFriction)*this.dragSpeed,r=c+cos(E)*v,a=i+sin(E)*v,w=r>l?l+(r-l)*h:r<m?m+(r-m)*h:r,A=a>d?d+(a-d)*h:a<u?u+(a-u)*h:a,o=this.destX=clamp(round(snap(w,this.snapX),5),m,l),s=this.destY=clamp(round(snap(A,this.snapY),5),u,d),T=this.isOutOfBounds(this.containerBounds,r,a);let t=0,e=0,S=f,C=f,p=0;if(g.x=c,g.y=i,!b){const i=o===l?c>l?-1:1:c<m?-1:1,e=round(c-o,0);x.velocity=y&&n?e?v*i/abs(e):0:_;const{ease:a,duration:s,restDuration:r}=x;t=c===o?0:n?s:s-r*globals.timeScale,n&&(S=a),t>p&&(p=t)}if(!y){const a=s===d?i>d?-1:1:i<u?-1:1,t=round(i-s,0);k.velocity=b&&n?t?v*a/abs(t):0:_;const{ease:r,duration:o,restDuration:c}=k;e=i===s?0:n?o:o-c*globals.timeScale,n&&(C=r),e>p&&(p=e)}if(!n&&T&&h&&(t||e)){const n=compositionTypes.blend;new JSAnimation(g,{x:{to:w,duration:t*.65},y:{to:A,duration:e*.65},ease:f,composition:n}).init(),new JSAnimation(g,{x:{to:o,duration:t},y:{to:s,duration:e},ease:f,composition:n}).init(),this.overshootXTicker.stretch(t).restart(),this.overshootYTicker.stretch(e).restart()}else b||this.animate[this.xProp](o,t,S),y||this.animate[this.yProp](s,e,C);this.scrollInView(p,this.scrollThreshold,f);let j=!1;o!==R&&(this.snapped[0]=o,this.snapX&&(j=!0)),s!==L&&this.snapY&&(this.snapped[1]=s,this.snapY&&(j=!0)),j&&this.onSnap(this),this.grabbed=!1,this.dragged=!1,this.updated=!0,this.released=!0,this.onRelease(this),this.$trigger.removeEventListener("touchstart",preventDefault),this.$trigger.removeEventListener("touchmove",preventDefault),this.$trigger.removeEventListener("touchend",preventDefault),doc.removeEventListener("touchmove",this),doc.removeEventListener("touchend",this),doc.removeEventListener("touchcancel",this),doc.removeEventListener("mousemove",this),doc.removeEventListener("mouseup",this),doc.removeEventListener("selectstart",this)}reset(){return this.stop(),this.resizeTicker.pause(),this.grabbed=!1,this.dragged=!1,this.updated=!1,this.released=!1,this.canScroll=!1,this.setX(0,!0),this.setY(0,!0),this.coords[0]=0,this.coords[1]=0,this.pointer[0]=0,this.pointer[1]=0,this.pointer[2]=0,this.pointer[3]=0,this.pointer[4]=0,this.pointer[5]=0,this.pointer[6]=0,this.pointer[7]=0,this.velocity=0,this.velocityStack[0]=0,this.velocityStack[1]=0,this.velocityStack[2]=0,this.velocityStackIndex=0,this.angle=0,this}enable(){return this.enabled||(this.enabled=!0,this.$target.classList.remove("is-disabled"),this.touchActionStyles=setTargetValues(this.$trigger,{touchAction:this.disabled[0]?"pan-x":this.disabled[1]?"pan-y":"none"}),this.$trigger.addEventListener("touchstart",this,{passive:!0}),this.$trigger.addEventListener("mousedown",this,{passive:!0}),this.$trigger.addEventListener("mouseenter",this)),this}disable(){return this.enabled=!1,this.grabbed=!1,this.dragged=!1,this.updated=!1,this.released=!1,this.canScroll=!1,this.touchActionStyles.revert(),this.cursorStyles&&(this.cursorStyles.revert(),this.cursorStyles=null),this.triggerStyles&&(this.triggerStyles.revert(),this.triggerStyles=null),this.bodyStyles&&(this.bodyStyles.revert(),this.bodyStyles=null),this.targetStyles&&(this.targetStyles.revert(),this.targetStyles=null),this.stop(),this.$target.classList.add("is-disabled"),this.$trigger.removeEventListener("touchstart",this),this.$trigger.removeEventListener("mousedown",this),this.$trigger.removeEventListener("mouseenter",this),doc.removeEventListener("touchmove",this),doc.removeEventListener("touchend",this),doc.removeEventListener("touchcancel",this),doc.removeEventListener("mousemove",this),doc.removeEventListener("mouseup",this),doc.removeEventListener("selectstart",this),this}revert(){return this.reset(),this.disable(),this.$target.classList.remove("is-disabled"),this.updateTicker.revert(),this.overshootXTicker.revert(),this.overshootYTicker.revert(),this.resizeTicker.revert(),this.animate.revert(),this}handleEvent(e){switch(e.type){case"mousedown":this.handleDown(e);break;case"touchstart":this.handleDown(e);break;case"mousemove":this.handleMove(e);break;case"touchmove":this.handleMove(e);break;case"mouseup":this.handleUp();break;case"touchend":this.handleUp();break;case"touchcancel":this.handleUp();break;case"mouseenter":this.handleHover();break;case"selectstart":preventDefault(e);break}}}const createDraggable=(e,t)=>new Draggable(e,t);class Scope{constructor(e={}){globals.scope&&globals.scope.revertibles.push(this);const t=e.root;let s=doc;t&&(s=t.current||t.nativeElement||parseTargets(t)[0]||doc);const o=e.defaults,i=globals.defaults,n=e.mediaQueries;if(this.defaults=o?mergeObjects(o,i):i,this.root=s,this.constructors=[],this.revertConstructors=[],this.revertibles=[],this.methods={},this.matches={},this.mediaQueryLists={},this.data={},n)for(let e in n){const t=win.matchMedia(n[e]);this.mediaQueryLists[e]=t,t.addEventListener("change",this)}}execute(e){let n=globals.scope,s=globals.root,o=globals.defaults;globals.scope=this,globals.root=this.root,globals.defaults=this.defaults;const t=this.mediaQueryLists;for(let e in t)this.matches[e]=t[e].matches;const i=e(this);return globals.scope=n,globals.root=s,globals.defaults=o,i}refresh(){return this.execute(()=>{let e=this.revertibles.length,t=this.revertConstructors.length;for(;e--;)this.revertibles[e].revert();for(;t--;)this.revertConstructors[t](this);this.revertibles.length=0,this.revertConstructors.length=0,this.constructors.forEach(e=>{const t=e(this);t&&this.revertConstructors.push(t)})}),this}add(e,t){if(isFnc(e)){const t=e;this.constructors.push(t),this.execute(()=>{const e=t(this);e&&this.revertConstructors.push(e)})}else this.methods[e]=(...e)=>this.execute(()=>t(...e));return this}handleEvent(e){switch(e.type){case"change":this.refresh();break}}revert(){const e=this.revertibles,t=this.revertConstructors,n=this.mediaQueryLists;let s=e.length,o=t.length;for(;s--;)e[s].revert();for(;o--;)t[o](this);for(let e in n)n[e].removeEventListener("change",this);e.length=0,t.length=0,this.constructors.length=0,this.matches={},this.methods={},this.mediaQueryLists={},this.data={}}}const createScope=e=>new Scope(e),getMaxViewHeight=()=>{const e=document.createElement("div");doc.body.appendChild(e),e.style.height="100lvh";const t=e.offsetHeight;return doc.body.removeChild(e),t},parseScrollObserverFunctionParameter=(e,t)=>e&&isFnc(e)?e(t):e,scrollContainers=new Map;class ScrollContainer{constructor(e){this.element=e,this.useWin=this.element===doc.body,this.winWidth=0,this.winHeight=0,this.width=0,this.height=0,this.left=0,this.top=0,this.zIndex=0,this.scrollX=0,this.scrollY=0,this.prevScrollX=0,this.prevScrollY=0,this.scrollWidth=0,this.scrollHeight=0,this.velocity=0,this.backwardX=!1,this.backwardY=!1,this.scrollTicker=new Timer({autoplay:!1,onBegin:()=>this.dataTimer.resume(),onUpdate:()=>{const e=this.backwardX||this.backwardY;forEachChildren(this,e=>e.handleScroll(),e)},onComplete:()=>this.dataTimer.pause()}).init(),this.dataTimer=new Timer({autoplay:!1,frameRate:30,onUpdate:e=>{const i=e.deltaTime,a=this.prevScrollX,r=this.prevScrollY,t=this.scrollX,n=this.scrollY,s=a-t,o=r-n;this.prevScrollX=t,this.prevScrollY=n,s&&(this.backwardX=a>t),o&&(this.backwardY=r>n),this.velocity=round(i>0?Math.sqrt(s*s+o*o)/i:0,5)}}).init(),this.resizeTicker=new Timer({autoplay:!1,duration:250*globals.timeScale,onComplete:()=>{this.updateWindowBounds(),this.refreshScrollObservers(),this.handleScroll()}}).init(),this.wakeTicker=new Timer({autoplay:!1,duration:500*globals.timeScale,onBegin:()=>{this.scrollTicker.resume()},onComplete:()=>{this.scrollTicker.pause()}}).init(),this._head=null,this._tail=null,this.updateScrollCoords(),this.updateWindowBounds(),this.updateBounds(),this.refreshScrollObservers(),this.handleScroll(),this.resizeObserver=new ResizeObserver(()=>this.resizeTicker.restart()),this.resizeObserver.observe(this.element),(this.useWin?win:this.element).addEventListener("scroll",this,!1)}updateScrollCoords(){const e=this.useWin,t=this.element;this.scrollX=round(e?win.scrollX:t.scrollLeft,0),this.scrollY=round(e?win.scrollY:t.scrollTop,0)}updateWindowBounds(){this.winWidth=win.innerWidth,this.winHeight=getMaxViewHeight()}updateBounds(){const e=getComputedStyle(this.element),t=this.element;this.scrollWidth=t.scrollWidth+parseFloat(e.marginLeft)+parseFloat(e.marginRight),this.scrollHeight=t.scrollHeight+parseFloat(e.marginTop)+parseFloat(e.marginBottom),this.updateWindowBounds();let n,s;if(this.useWin)n=this.winWidth,s=this.winHeight;else{const e=t.getBoundingClientRect();n=e.width,s=e.height,this.top=e.top,this.left=e.left}this.width=n,this.height=s}refreshScrollObservers(){forEachChildren(this,e=>{e._debug&&e.removeDebug()}),this.updateBounds(),forEachChildren(this,e=>{e.refresh(),e._debug&&e.debug()})}refresh(){this.updateWindowBounds(),this.updateBounds(),this.refreshScrollObservers(),this.handleScroll()}handleScroll(){this.updateScrollCoords(),this.wakeTicker.restart()}handleEvent(e){switch(e.type){case"scroll":this.handleScroll();break}}revert(){this.scrollTicker.cancel(),this.dataTimer.cancel(),this.resizeTicker.cancel(),this.wakeTicker.cancel(),this.resizeObserver.unobserve(this.element),(this.useWin?win:this.element).removeEventListener("scroll",this),scrollContainers.delete(this.element)}}const registerAndGetScrollContainer=e=>{const n=e?parseTargets(e)[0]||doc.body:doc.body;let t=scrollContainers.get(n);return t||(t=new ScrollContainer(n),scrollContainers.set(n,t)),t},convertValueToPx=(e,t,n,s,o)=>{const a=t==="min",r=t==="max",d=t==="top"||t==="left"||t==="start"||a?0:t==="bottom"||t==="right"||t==="end"||r?"100%":t==="center"?"50%":t,{n:c,u:l}=decomposeRawValue(d,decomposedOriginalValue);let i=c;return l==="%"?i=c/100*n:l&&(i=convertValueUnit(e,decomposedOriginalValue,"px",!0).n),r&&s<0&&(i+=s),a&&o>0&&(i+=o),i},parseBoundValue=(e,t,n,s,o)=>{let i;if(isStr(t)){const a=relativeValuesExecRgx.exec(t);if(a){const u=a[0],l=u[0],c=t.split(u),h=c[0]==="min",m=c[0]==="max",r=convertValueToPx(e,c[0],n,s,o),d=convertValueToPx(e,c[1],n,s,o);if(h){const t=getRelativeValue(convertValueToPx(e,"min",n),d,l);i=t<r?r:t}else if(m){const t=getRelativeValue(convertValueToPx(e,"max",n),d,l);i=t>r?r:t}else i=getRelativeValue(r,d,l)}else i=convertValueToPx(e,t,n,s,o)}else i=t;return round(i,0)},getAnimationDomTarget=e=>{let t;const n=e.targets;for(let e=0,o=n.length;e<o;e++){const s=n[e];if(s[isDomSymbol]){t=s;break}}return t};let scrollerIndex=0;const debugColors=["#FF4B4B","#FF971B","#FFC730","#F9F640","#7AFF5A","#18FF74","#17E09B","#3CFFEC","#05DBE9","#33B3F1","#638CF9","#C563FE","#FF4FCF","#F93F8A"];class ScrollObserver{constructor(e={}){globals.scope&&globals.scope.revertibles.push(this);const n=setValue(e.sync,"play pause"),r=n?parseEasings(n):null,o=n&&(n==="linear"||n===none),i=n&&!(r===none&&!o),a=n&&(isNum(n)||n===!0||o),c=n&&isStr(n)&&!i&&!a,t=c?n.split(" ").map(e=>()=>{const t=this.linked;return t&&t[e]?t[e]():null}):null,s=c&&t.length>2;this.index=scrollerIndex++,this.id=isUnd(e.id)?this.index:e.id,this.container=registerAndGetScrollContainer(e.container),this.target=null,this.linked=null,this.repeat=null,this.horizontal=null,this.enter=null,this.leave=null,this.sync=i||a||!!t,this.syncEase=i?r:null,this.syncSmooth=a?n===!0||o?1:n:null,this.onSyncEnter=t&&!s&&t[0]?t[0]:noop,this.onSyncLeave=t&&!s&&t[1]?t[1]:noop,this.onSyncEnterForward=t&&s&&t[0]?t[0]:noop,this.onSyncLeaveForward=t&&s&&t[1]?t[1]:noop,this.onSyncEnterBackward=t&&s&&t[2]?t[2]:noop,this.onSyncLeaveBackward=t&&s&&t[3]?t[3]:noop,this.onEnter=e.onEnter||noop,this.onLeave=e.onLeave||noop,this.onEnterForward=e.onEnterForward||noop,this.onLeaveForward=e.onLeaveForward||noop,this.onEnterBackward=e.onEnterBackward||noop,this.onLeaveBackward=e.onLeaveBackward||noop,this.onUpdate=e.onUpdate||noop,this.onSyncComplete=e.onSyncComplete||noop,this.reverted=!1,this.completed=!1,this.began=!1,this.isInView=!1,this.forceEnter=!1,this.hasEntered=!1,this.offsets=[],this.offset=0,this.offsetStart=0,this.offsetEnd=0,this.distance=0,this.prevProgress=0,this.thresholds=["start","end","end","start"],this.coords=[0,0,0,0],this.debugStyles=null,this.$debug=null,this._params=e,this._debug=setValue(e.debug,!1),this._next=null,this._prev=null,addChild(this.container,this),sync(()=>{if(this.reverted)return;if(!this.target){const t=parseTargets(e.target)[0];this.target=t||doc.body,this.refresh()}this._debug&&this.debug()})}link(e){if(e&&(e.pause(),this.linked=e,!this._params.target)){let t;isUnd(e.targets)?forEachChildren(e,e=>{e.targets&&!t&&(t=getAnimationDomTarget(e))}):t=getAnimationDomTarget(e),this.target=t||doc.body,this.refresh()}return this}get velocity(){return this.container.velocity}get backward(){return this.horizontal?this.container.backwardX:this.container.backwardY}get scroll(){return this.horizontal?this.container.scrollX:this.container.scrollY}get progress(){const e=(this.scroll-this.offsetStart)/this.distance;return e===1/0||isNaN(e)?0:round(clamp(e,0,1),6)}refresh(){this.reverted=!1;const e=this._params;return this.repeat=setValue(parseScrollObserverFunctionParameter(e.repeat,this),!0),this.horizontal=setValue(parseScrollObserverFunctionParameter(e.axis,this),"y")==="x",this.enter=setValue(parseScrollObserverFunctionParameter(e.enter,this),"end start"),this.leave=setValue(parseScrollObserverFunctionParameter(e.leave,this),"start end"),this.updateBounds(),this.handleScroll(),this}removeDebug(){return this.$debug&&(this.$debug.parentNode.removeChild(this.$debug),this.$debug=null),this.debugStyles&&(this.debugStyles.revert(),this.$debug=null),this}debug(){this.removeDebug();const t=this.container,e=this.horizontal,f=t.element.querySelector(":scope > .animejs-onscroll-debug"),s=doc.createElement("div"),h=doc.createElement("div"),d=doc.createElement("div"),a=debugColors[this.index%debugColors.length],y=t.useWin,j=y?t.winWidth:t.width,b=y?t.winHeight:t.height,m=t.scrollWidth,g=t.scrollHeight,o=this.container.width>360?320:260,w=e?0:10,_=e?10:0,n=e?24:o/2,i=e?n:15,p=e?60:n,v=e?p:i,u=e?"repeat-x":"repeat-y",l=t=>e?"0px "+t+"px":t+"px 2px",c=t=>`linear-gradient(${e?90:0}deg, ${t} 2px, transparent 1px)`,r=(e,t,n,s,o)=>`position:${e};left:${t}px;top:${n}px;width:${s}px;height:${o}px;`;s.style.cssText=`${r("absolute",w,_,e?m:o,e?o:g)}
      pointer-events: none;
      z-index: ${this.container.zIndex++};
      display: flex;
      flex-direction: ${e?"column":"row"};
      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));
    `,h.style.cssText=`${r("sticky",0,0,e?j:n,e?n:b)}`,f||(h.style.cssText+=`background:
        ${c("#FFFF")}${l(n-10)} / ${e?"100px 100px":"100px 100px"} ${u},
        ${c("#FFF8")}${l(n-10)} / ${e?"10px 10px":"10px 10px"} ${u};
      `),d.style.cssText=`${r("relative",0,0,e?m:n,e?n:g)}`,f||(d.style.cssText+=`background:
        ${c("#FFFF")}${l(0)} / ${e?"100px 10px":"10px 100px"} ${u},
        ${c("#FFF8")}${l(0)} / ${e?"10px 0px":"0px 10px"} ${u};
      `);const O=[" enter: "," leave: "];this.coords.forEach((t,n)=>{const c=n>1,f=(c?0:this.offset)+t,l=n%2,_=f<v,w=f>(c?e?j:b:e?m:g)-v,s=(c?l&&!_:!l&&!_)||w,u=doc.createElement("div"),y=doc.createElement("div"),x=e?s?"right":"left":s?"bottom":"top",C=s?(e?p:i)+(c?e?-1:w?0:-2:e?-1:-2):c?e?1:0:e?1:0;y.innerHTML=`${this.id}${O[l]}${this.thresholds[n]}`,u.style.cssText=`${r("absolute",0,0,p,i)}
        display: flex;
        flex-direction: ${e?"column":"row"};
        justify-content: flex-${c?"start":"end"};
        align-items: flex-${s?"end":"start"};
        border-${x}: 2px ${l?"solid":"solid"} ${a};
      `,y.style.cssText=`
        overflow: hidden;
        max-width: ${o/2-10}px;
        height: ${i};
        margin-${e?s?"right":"left":s?"bottom":"top"}: -2px;
        padding: 1px;
        font-family: ui-monospace, monospace;
        font-size: 10px;
        letter-spacing: -.025em;
        line-height: 9px;
        font-weight: 600;
        text-align: ${e&&s||!e&&!c?"right":"left"};
        white-space: pre;
        text-overflow: ellipsis;
        color: ${l?a:"rgba(0,0,0,.75)"};
        background-color: ${l?"rgba(0,0,0,.65)":a};
        border: 2px solid ${l?a:"transparent"};
        border-${e?s?"top-left":"top-right":s?"top-left":"bottom-left"}-radius: 5px;
        border-${e?s?"bottom-left":"bottom-right":s?"top-right":"bottom-right"}-radius: 5px;
      `,u.appendChild(y);let E=f-C+(e?1:0);u.style[e?"left":"top"]=`${E}px`,(c?h:d).appendChild(u)}),s.appendChild(h),s.appendChild(d),t.element.appendChild(s),f||s.classList.add("animejs-onscroll-debug"),this.$debug=s;const x=getTargetValue(t.element,"position");x==="static"&&(this.debugStyles=setTargetValues(t.element,{position:"relative "}))}updateBounds(){this._debug&&this.removeDebug();let r;const t=this.target,n=this.container,h=this.horizontal,l=this.linked;let y,e=t,f=0,p=0,b=e;l&&(y=l.currentTime,l.seek(0,!0));const j=getTargetValue(n.element,"position")==="static"&&setTargetValues(n.element,{position:"relative "});for(;e&&e!==n.element&&e!==doc.body;){const t=getTargetValue(e,"position")==="sticky"&&setTargetValues(e,{position:"static"});e===b&&(f+=e.offsetLeft||0,p+=e.offsetTop||0,b=e.offsetParent),e=e.parentElement,t&&(r||(r=[]),r.push(t))}j&&j.revert();const u=h?f:p,_=h?t.offsetWidth:t.offsetHeight,m=h?n.width:n.height,M=h?n.scrollWidth:n.scrollHeight,S=M-m,o=this.enter,s=this.leave;let d="start",i="end",c="end",a="start";if(isStr(o)){const e=o.split(" ");c=e[0],d=e.length>1?e[1]:d}else if(isObj(o)){const e=o;isUnd(e.container)||(c=e.container),isUnd(e.target)||(d=e.target)}else isNum(o)&&(c=o);if(isStr(s)){const e=s.split(" ");a=e[0],i=e.length>1?e[1]:i}else if(isObj(s)){const e=s;isUnd(e.container)||(a=e.container),isUnd(e.target)||(i=e.target)}else isNum(s)&&(a=s);const v=parseBoundValue(t,d,_),g=parseBoundValue(t,i,_),w=v+u-m,O=g+u-S,x=parseBoundValue(t,c,m,w,O),C=parseBoundValue(t,a,m,w,O),E=v+u-x,k=g+u-C,A=k-E;this.offsets[0]=f,this.offsets[1]=p,this.offset=u,this.offsetStart=E,this.offsetEnd=k,this.distance=A<=0?0:A,this.thresholds=[d,i,c,a],this.coords=[v,g,x,C],r&&r.forEach(e=>e.revert()),l&&l.seek(y,!0),this._debug&&this.debug()}handleScroll(){const n=this.linked,i=this.sync,l=this.syncEase,t=this.syncSmooth,f=n&&(l||t),m=this.horizontal,d=this.container,r=this.scroll,u=r<=this.offsetStart,g=r>=this.offsetEnd,s=!u&&!g,p=r===this.offsetStart||r===this.offsetEnd,h=!this.hasEntered&&p,o=this._debug&&this.$debug;let c=!1,a=!1,e=this.progress;if(u&&this.began&&(this.began=!1),e>0&&!this.began&&(this.began=!0),f){const s=n.progress;if(t&&isNum(t)){if(t<1){const n=1e-4,o=s<e&&e===1?n:s>e&&!e?-1e-4:0;e=round(lerp(s,e,interpolate(.01,.2,t),!1)+o,6)}}else l&&(e=l(e));c=e!==this.prevProgress,a=s===1,c&&!a&&t&&s&&d.wakeTicker.restart()}if(o){const e=m?d.scrollY:d.scrollX;o.style[m?"top":"left"]=e+10+"px"}(s&&!this.isInView||h&&!this.forceEnter&&!this.hasEntered)&&(s&&(this.isInView=!0),!this.forceEnter||!this.hasEntered?(o&&s&&(o.style.zIndex=`${this.container.zIndex++}`),this.onSyncEnter(this),this.onEnter(this),this.backward?(this.onSyncEnterBackward(this),this.onEnterBackward(this)):(this.onSyncEnterForward(this),this.onEnterForward(this)),this.hasEntered=!0,h&&(this.forceEnter=!0)):s&&(this.forceEnter=!1)),(s||!s&&this.isInView)&&(c=!0),c&&(f&&n.seek(n.duration*e),this.onUpdate(this)),!s&&this.isInView&&(this.isInView=!1,this.onSyncLeave(this),this.onLeave(this),this.backward?(this.onSyncLeaveBackward(this),this.onLeaveBackward(this)):(this.onSyncLeaveForward(this),this.onLeaveForward(this)),i&&!t&&(a=!0)),e>=1&&this.began&&!this.completed&&(i&&a||!i)&&(i&&this.onSyncComplete(this),this.completed=!0,(!this.repeat&&!n||!this.repeat&&n&&n.completed)&&this.revert()),e<1&&this.completed&&(this.completed=!1),this.prevProgress=e}revert(){if(this.reverted)return;const e=this.container;return removeChild(e,this),e._head||e.revert(),this._debug&&this.removeDebug(),this.reverted=!0,this}}const onScroll=(e={})=>new ScrollObserver(e),stagger=(e,t={})=>{let n=[],i=0;const o=t.from,y=t.reversed,c=t.ease,m=!isUnd(c),g=m&&!isUnd(c.ease),h=g?c.ease:m?parseEasings(c):null,s=t.grid,l=t.axis,v=isUnd(o)||o===0||o==="first",d=o==="center",b=o==="last",r=isArr(e),u=parseNumber(r?e[0]:e),j=r?parseNumber(e[1]):0,f=unitsExecRgx.exec((r?e[1]:e)+emptyString),p=t.start||0+(r?u:0);let a=v?0:isNum(o)?o:0;return(e,o,c,m)=>{if(d&&(a=(c-1)/2),b&&(a=c-1),!n.length){for(let e=0;e<c;e++){if(s){const r=d?(s[0]-1)/2:a%s[0],c=d?(s[1]-1)/2:floor(a/s[0]),u=e%s[0],h=floor(e/s[0]),t=r-u,o=c-h;let i=sqrt(t*t+o*o);l==="x"&&(i=-t),l==="y"&&(i=-o),n.push(i)}else n.push(abs(a-e));i=max(...n)}h&&(n=n.map(e=>h(e/i)*i)),y&&(n=n.map(e=>l?e<0?e*-1:-e:abs(i-e)))}const v=r?(j-u)/i:u,_=m?parseTimelinePosition(m,isUnd(t.start)?m.iterationDuration:p):p;let g=_+(v*round(n[o],2)||0);return t.modifier&&(g=t.modifier(g)),f&&(g=`${g}${f[2]}`),g}};export{Animatable,Draggable,JSAnimation,Scope,ScrollObserver,Spring,Timeline,Timer,WAAPIAnimation,animate,createAnimatable,createDraggable,createScope,createSpring,createTimeline,createTimer,eases,engine,onScroll,scrollContainers,stagger,svg,utils,waapi}