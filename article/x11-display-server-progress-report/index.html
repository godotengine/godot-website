<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Godot Engine">
	<meta name="description" content="Progress report on the changes made in the X11 display server, the window management system for Godot 4 on Linux.">
	<meta name="theme-color" content="#3d8fcc">
	<meta property="og:site_name" content="Godot Engine">
	<meta property="og:url" content="https://godotengine.org/article/x11-display-server-progress-report/">
	<meta name="twitter:site" content="@godotengine">

	<meta property="og:title" content="X11 display server progress report">
	<meta property="og:description" content="Progress report on the changes made in the X11 display server, the window management system for Godot 4 on Linux.">
	<meta property="og:image" content="https://godotengine.org/storage/app/uploads/public/5f8/d66/bae/5f8d66bae9125677247883.png">
	<meta property="og:type" content="article">
	<meta name="twitter:card" content="summary_large_image">
	<title>X11 display server progress report</title>

	<link rel="alternate" type="application/rss+xml" title="Godot News" href="/rss.xml">
	<link rel="icon" href="/assets/favicon.png" sizes="any">
	<link rel="icon" href="/assets/favicon.svg" type="image/svg+xml">
	<link rel="stylesheet" href="/assets/css/main.css?111">
	<link rel="stylesheet" href="/assets/css/tobii.min.css">
	<link rel="preload" as="font" href="/assets/fonts/Montserrat-Bold.woff2" crossorigin>
	<link rel="preload" as="font" href="/assets/fonts/Montserrat-ExtraBold.woff2" crossorigin>
	<link rel="me" href="https://mastodon.gamedev.place/@godotengine">
</head>

<body>
	<input type="checkbox" id="nav_toggle_cb">
<header>
	<div class="container flex align-center">
		<div id="nav_head">
			<a href="/" id="logo-link">
				<img class="nav-logo" src="/assets/logo.svg" width="136" height="48" alt="Godot Engine">
				<img class="nav-logo dark-logo" src="/assets/logo_dark.svg" width="136" height="48" alt="Godot Engine">
			</a>
			<label for="nav_toggle_cb" id="nav_toggle_btn">
				<img src="/assets/icons/hamburger.svg" width="24" height="24" alt="Main menu">
			</label>
		</div>

		<nav id="nav">
			<ul class="left">
				<li><a href="/features">Features</a></li>
				<li class="only-on-mobile"><a href="/showcase">Showcase</a></li>
				<li><a href="/blog">Blog</a></li>
				<li><a href="/community">Community</a></li>
				<li><a href="/contact">About</a></li>
				<li><a href="https://godotengine.org/asset-library/asset">Assets</a></li>
			</ul>

			<ul class="right">
				<li><a href="/download/windows" class="set-os-download-url">Download</a></li>
				<li><a href="https://docs.godotengine.org">Learn</a></li>
				<li><a href="https://docs.godotengine.org/en/stable/community/contributing/index.html">Contribute</a></li>
				
				<li class="fund"><a href="https://fund.godotengine.org">❤&#xFE0E; Donate</a></li>
			</ul>
		</nav>
	</div>
</header>

<main>


<style>
	body {
		background-color: var(--background-color);
	}

	h1 {
		margin-bottom: 8px;
		margin-top: 32px;
	}

	:not(pre)>code {
		background: var(--code-background-color);
		padding: 1px 4px;
		font-size: 0.95em;
		border-radius: 3px;
	}

	pre {
		background: var(--codeblock-background-color);
		color: var(--codeblock-color);
	}

	pre code {
		display: block;
		overflow-x: auto;
		padding: .5em;
	}

	.date-big {
		line-height: 2;
		margin-left: 32px;
	}

	article {
		background-color: var(--base-color);
		box-shadow: 0px 3px 2px 0px rgba(0, 0, 0, 0.15);
	}

	figure {
		margin: 0;
	}

	figure img {
		margin: 0;
	}

	article img,
	article video {
		max-width: 100%;
		height: auto;
		display: block;
		margin: auto;
		margin-top: 16px;
		margin-bottom: 16px;
	}

	article h1 {
		margin-top: 64px;
	}

	article h2,
	article h3,
	article h4 {
		margin-top: 42px;
	}

	.article-info {
		display: flex;
		flex-direction: column;
		gap: 8px;
	}

	.article-metadata {
		display: flex;
		gap: 24px;
		align-items: center;
		font-family: var(--header-font-family);
		margin-bottom: 12px;
	}

	@media (max-width: 900px) {
		.article-metadata {
			flex-direction: column;
			align-items: flex-start;
			gap: 16px;
		}
	}

	.article-author {
		color: var(--base-color-text-subtitle-date);
		font-weight: 700;
		font-size: 18px;
		flex-grow: 1;
		display: flex;
		gap: 12px;
		align-items: center;
	}

	.article-author .avatar {
		border-radius: 100%;
		margin: 0;
	}

	.article-author .by {
		color: var(--base-color-text-subtitle);
	}

	.article-metadata .date {
		color: var(--base-color-text-subtitle-date);
	}

	.article-metadata .date.post-recent-highlight {
		color: var(--post-recent-highlight-color);
		opacity: 0.8;
	}

	.article-metadata .date.post-recent-highlight::after {
		font-size: 80%;
		content: "NEW";
		border: 2px solid var(--post-recent-highlight-color);
		padding: 2px 3px;
		margin-left: 8px;
	}

	.tag.active {
		filter: saturate(0.75);
	}

	@media screen and (min-width: 900px) {
		article .content {
			width: 70%;
			margin: auto;
		}
	}

	@media (max-width: 900px) {
		body {
			background-color: var(--base-color);
		}

		article {
			background-color: transparent;
			box-shadow: none;
		}

		article img:first-child,
		article video:first-child {
			max-width: 100%;
		}
	}
</style>

<link rel="stylesheet" href="/assets/css/highlight.obsidian.min.css">

<div class="container">
	<article class="padded">
		<div class="content article-container">
			<figure class="article-cover">
				

				<img src="/storage/app/uploads/public/5f8/d66/bae/5f8d66bae9125677247883.png" title=""
					alt=" " class="rounded-lg"
					style="width: 100%; height: auto; background-color: transparent;" />
			</figure>

			<div class="article-info">
				<h1>
					X11 display server progress report
				</h1>
				<div class="article-metadata">
					<div class="article-author">
						<span>By: </span>
						
						
							<img class="avatar" width="25" height="25" src="/assets/images/authors/default_avatar.svg" alt="Camille Mohr-Daurat" loading="lazy">
						
						<span class="by">Camille Mohr-Daurat</span>
					</div>
					<span class="date" data-post-date="2020-10-20 07:40:00 +0000"> 20 October 2020</span>
				</div>

				<div class="tags">
					
					<a href="/blog/progress-report">
						<div class="tag active">Progress Report</div>
					</a>
					
				</div>
			</div>

			



	<div class="card card-warning">
		<p>
		
			This article is from <strong>October 2020</strong>, some of its contents might be outdated and no longer accurate.<br>
			You can find up-to-date information about the engine in the <a href="https://docs.godotengine.org/en/stable/">official documentation</a>.
		
		</p>
	</div>





			<div class="article-body">
				<p>Hi everybody!</p>

<p>I’m Camille, aka PouleyKetchoupp. I use Godot as an indie game developer (<a href="http://www.nekomatata.com/">Nekomatata</a>) and I’ve been a Godot contributor for a while (<a href="https://github.com/pouleyKetchoupp">Github</a>). Recently I was hired to work as a contractor on fixes and improvements for the Linux port of Godot 4.</p>

<p>Most of the work was dedicated to fixing regressions due to the new Display Server used for window management, which allows support for multiple windows. I’ve also spent some extra time fixing old issues we had with X11 which required some refactoring in how the engine communicates with the X server. Some of them will be available in a later Godot 3.2 release as well.</p>

<p>In this post I’m summarizing all the changes I’ve made in the X11 Display Server, in order to (hopefully) clarify how the X server works and how Godot communicates with it.</p>

<p>The fixes for multi-windows are about:</p>
<ul>
  <li>Delay with showing popups</li>
  <li>Popups position on multiple screens</li>
  <li>Drag &amp; drop between windows</li>
</ul>

<p>The more general X11 fixes are about:</p>
<ul>
  <li>Delay with keyboard inputs</li>
  <li>Clipboard fixes</li>
</ul>

<h1 id="general-things-for-starters">General things for starters</h1>

<p><strong>X11</strong> is the current protocol used in Unix window systems, describing how the X server works. It was designed more than 30 years ago, so despite its flexibility, some aspects of it can be troublesome in modern systems.</p>

<p><strong>Xlib</strong> is the original X client implementation. It’s the one used in Godot at the moment.</p>

<p><strong>XCB</strong> is a modern implementation of X11, which allows more flexibility in asynchronous exchanges with the X server. Recent versions of Xlib are actually built on top of XCB.</p>

<p><strong>Wayland</strong> is a new communication protocol, meant to replace X11 in modern systems even though it’s still not widely used.</p>

<h1 id="popups-delay">Popups delay</h1>

<p>After switching to a multi-windows system, some difficult problems started to show, especially on Linux. In the Godot 4 editor, we’re using separate windows for popup menus, tooltips and property fields when editing them.</p>

<p>The main issue was that all these windows were slow to show, causing a delay when interacting with almost anything in the editor.</p>

<p>The solution: override-redirect flag.</p>

<p>By default, any new window on the X server is handled through the Window Manager, responsible for switching focus between windows, moving, resizing and closing. But that comes with extra delays, which are unnecessary for simple enough windows like popups.</p>

<p>In order to fix that, the override-redirect flag can be set on those windows. To make it simple, it just tells the window manager to leave this window alone.</p>

<p>In the code, we set the <a href="https://tronche.com/gui/x/xlib/window/attributes/override-redirect.html"><code class="language-plaintext highlighter-rouge">override_redirect</code></a> flag in <a href="https://tronche.com/gui/x/xlib/window/attributes/#XSetWindowAttributes"><code class="language-plaintext highlighter-rouge">XSetWindowAttributes</code></a> - the structure we pass to <a href="https://tronche.com/gui/x/xlib/window/XCreateWindow.html"><code class="language-plaintext highlighter-rouge">XCreateWindow</code></a>, the function that creates the window on the X server.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>XSetWindowAttributes windowAttributes = {};
unsigned long valuemask = 0;

// override_redirect forces the WM not to interfere with the window,
// to avoid delays due to handling decorations and placement.
windowAttributes.override_redirect = True;

// save_under is an extra hint for the WM to keep the content of
// windows behind to avoid repaint.
windowAttributes.save_under = True;

// valuemask is used in XCreateWindow to specify which attributes are defined.
valuemask |= CWOverrideRedirect | CWSaveUnder;
</code></pre></div></div>

<p>But is it that simple? Not exactly. While it solves the delay problem, it also leaves us with all the responsibility to handle the window’s focus, which can be a hassle when dealing with stacks of windows, like in the case of sub-menu popups.</p>

<p>So in order to deal with that, our display server code has to take care of setting the focus on popups when they are created (after receiving an appropriate event from the X server), and switching focus back to the previous window when they are closed.</p>

<p>Most situations seem to work fine in the current version and it was tested on all the most common Window Managers. Contributions are welcome if specific cases still cause issues on certain Window Managers.</p>

<p>More details about popup windows in the X11 documentation <a href="https://www.x.org/releases/X11R7.6/doc/xorg-docs/specs/ICCCM/icccm.html#pop_up_windows">here</a>.</p>

<p>Pull Request: <a href="https://github.com/godotengine/godot/pull/41456">GH-41456</a></p>

<h1 id="popups-on-multiple-screens">Popups on multiple screens</h1>

<p>When working with multi-windows, we need to make sure the popup windows don’t show up outside of the available desktop area. So not only do we need to take into account the monitor size, but also decorations like the application bar.</p>

<p>Depending on the desktop environment you use and your custom settings, these decorations can be on any side of the screen.</p>

<p>That becomes even trickier on a multihead setup, as the decorations can be on one or more monitors, and the desktop manager doesn’t always provide all the information you need.</p>

<p>There are two properties which can help figuring out this available size in most cases: <a href="https://specifications.freedesktop.org/wm-spec/wm-spec-1.3.html#idm45805408034336">_NET_WORKAREA</a> and <code class="language-plaintext highlighter-rouge">_GTK_WORKAREAS_Dx</code> (I couldn’t find a link with proper specifications).</p>

<p>They are both accessed from the X server using atoms and the <a href="https://tronche.com/gui/x/xlib/window-information/XGetWindowProperty.html"><code class="language-plaintext highlighter-rouge">XGetWindowProperty</code></a> function.</p>

<p>An atom is just an integer identifier paired with a string that represents the property name, so the client code can work with names, while communication with the X server uses integer values.</p>

<p>Accessing a property looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Get _NET_WORKAREA atom from name.
Atom workarea_prop = XInternAtom(x11_display, "_NET_WORKAREA", True);

// Get _NET_WORKAREA property value, in this case an array of values.
Atom type;
int format = 0;
unsigned long len = 0;
unsigned long remaining = 0;
unsigned char *data = nullptr;
XGetWindowProperty(x11_display, x11_window, workarea_prop,
        0, // data offset
        LONG_MAX, // data length
        False, // should the property be deleted?
        XA_CARDINAL, // expected property type
        &amp;type, // returned property type
        &amp;format, // returned data format
        &amp;len, // returned data length
        &amp;remaining, // returned remaining length for partial data
        &amp;data); // returned data pointer
</code></pre></div></div>

<h4 id="_net_workarea">_NET_WORKAREA</h4>
<p>This property gives you the size and position of each desktop. But in the case of multiple monitors, it can still return only a global rectangle for all of them, which is not accurate when it comes to decorations, or for L shape configurations.</p>

<h4 id="_gtk_workareas">_GTK_WORKAREAS</h4>
<p>This property has been introduced by GNOME to provide a solution to this problem, and Godot will use it when possible. It’s similar to <code class="language-plaintext highlighter-rouge">_NET_WORKAREA</code>, but provides per-monitor desktop information, which is exactly what we need.</p>

<p>In order to be as accurate as possible when not on GNOME, the information from <code class="language-plaintext highlighter-rouge">_NET_WORKAREA</code> is cross-referenced with the monitors’ total size. It works ok in most cases, but this is not a perfect solution. For instance, in a vertical setup, it’s not possible to take a top bar into account on the bottom screen. So this area is still open for improvements if a better solution comes up in the future.</p>

<p>Pull Request: <a href="https://github.com/godotengine/godot/pull/41565">GH-41565</a></p>

<h1 id="drag--drop-between-windows">Drag &amp; drop between windows</h1>

<p>In order to make drag &amp; drop work properly from one window to another, we need to identify the top-most window at a certain screen position in any situation (overlapping floating windows is the most complex case).</p>

<p>A specific API is available on Windows or Mac for this purpose, but not on the Linux X server, so this had to be worked around a different way.</p>

<p>In order to solve this problem, Godot will have its own algorithm which:</p>
<ul>
  <li>Goes through each window to check which ones contain a certain position,</li>
  <li>Picks the top-most transient window in case of a stack,</li>
  <li>Picks the last one focused in case of separate floating windows.</li>
</ul>

<p>Pull Request: <a href="https://github.com/godotengine/godot/pull/41596">GH-41596</a></p>

<h1 id="keyboard-inputs-delay">Keyboard inputs delay</h1>

<p>A delay was sometimes visible when typing on the keyboard on Linux, especially on low-end configurations. This happened to be due to how Godot processed input events and handled the X11 Input Method.</p>

<p>The Input Method (IM) is the part of the X server responsible for handling inputs, mainly for the purpose of handling international characters. It’s used to filter key inputs, take some key combinations into accounts for special characters and display decorations when needed to give feedback to the user.</p>

<p>For this system to work properly, several steps are needed before X11 applications can use keyboard events:</p>
<ol>
  <li>The application receives a key event from the X server</li>
  <li>The application sends the key event to the IM for filtering</li>
  <li>The IM sends a new key event to the X server</li>
  <li>The application receives a new key event that it can use</li>
</ol>

<p>The problem was that Godot was processing events from the X server only on the main thread. Because this process doesn’t happen all synchronously, Godot had to wait for one more frame after first detecting the input before it could use it. Depending on how fast your computer renders, this lag could be more or less noticeable.</p>

<p>In order to improve the situation, Godot is now running a separate thread where it receives X events. In the case of keyboard events, it can send it to the IM for filtering right away, and receive the new event all before the next loop, when input events are propagated to the engine.</p>

<p>More details about event filtering in the X11 documentation <a href="https://www.x.org/releases/X11R7.6/doc/libX11/specs/XIM/xim.html#filtering_events">here</a>.</p>

<p>Pull Request: <a href="https://github.com/godotengine/godot/pull/41910">GH-41910</a></p>

<h1 id="clipboard-fixes">Clipboard fixes</h1>

<p>In a similar way as for keyboard events, copy/paste protocols in X11 are highly asynchronous, which doesn’t play well with the way Godot was processing X events only on the main thread, and expects any action to be synchronous.</p>

<p>This has led to multiple issues around clipboard which are difficult to solve without a refactoring of the way X events are processed.</p>

<p>As a workaround, based on the work made for the keyboard inputs, I’ve made fixes to several cases using the new event processing loop, without the need for a full refactoring.</p>

<h4 id="1-delay-when-pasting-from-godot-into-other-apps">1. Delay when pasting from Godot into other apps</h4>

<p>When working with X11, clipboard data is not just saved in the system and sent to an app when pasting is requested. Instead, communication is needed with the app that the data comes from in order to convert it to the desired format and send it through the X server to the other app.</p>

<p>The steps for copy/pasting are as follows:</p>
<ul>
  <li>Copy happens in App A, which is registered as the clipboard owner</li>
  <li>Paste happens in App B, which requests data from the X server</li>
  <li>The X server sends a SelectionRequest event to the owner, App A</li>
  <li>App A converts the data and sends a SelectionNotify event to the X server</li>
  <li>The X server transfers the SelectionNotify event to App B</li>
  <li>App B accesses the converted data from the X server</li>
</ul>

<p>It usually takes even more steps, because multiple requests are actually needed, first to get the list of all possible formats the data can be converted to, then to request several formats if needed.</p>

<p>In the case events are only processed on the main thread, that leads to a very long delay when another application asks for clipboard data that comes from Godot, because each SelectionRequest has to wait for one more frame to be processed. This lag is even amplified when Godot is unfocused, as it runs at a lower frequency to save system resources.</p>

<p>This case was fixed by processing SelectionRequest events on a separate thread, so the data can be sent immediately to the X server.</p>

<p>Pull Request: <a href="https://github.com/godotengine/godot/pull/41910">GH-41910</a></p>

<h4 id="2-save_targets-protocol-keep-clipboard-data-on-exit">2. SAVE_TARGETS protocol (keep clipboard data on exit)</h4>

<p>Because clipboard data is sent by the source application at the moment it’s pasted, there are cases where it can be lost when the application closes.</p>

<p>As a note, most modern desktop environments have a clipboard manager which keeps a backup to avoid this problem, but not all of them, so it still happens in some cases.</p>

<p>The proper way to make the clipboard always work after Godot has closed is to implement <code class="language-plaintext highlighter-rouge">SAVE_TARGETS</code> protocol. The principle is that just before the closing, the application transfers the clipboard data to the clipboard manager, if supported.</p>

<p>There’s not much documentation I could find about this protocol, but there are implementation examples <a href="https://github.com/glfw/glfw/blob/master/src/x11_window.c">here</a> and <a href="https://gitlab.gnome.org/GNOME/gtk/-/blob/master/gdk/x11/gdkclipboard-x11.c">there</a>.</p>

<p>The first step to start the protocol is to call <a href="https://tronche.com/gui/x/xlib/window-information/XConvertSelection.html"><code class="language-plaintext highlighter-rouge">XConvertSelection</code></a> on the X server just before the application exits, using <code class="language-plaintext highlighter-rouge">CLIPBOARD_MANAGER</code> as the selection atom and <code class="language-plaintext highlighter-rouge">SAVE_TARGETS</code> as the target atom. This asks the X server to transfer ownership of the clipboard data from the current owner (Godot in this case) to the clipboard manager.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Atom clipboard_manager = XInternAtom(x11_display, "CLIPBOARD_MANAGER", False);
Atom save_targets = XInternAtom(x11_display, "SAVE_TARGETS", False);
XConvertSelection(x11_display, clipboard_manager, save_targets, None,
        x11_window, CurrentTime);
</code></pre></div></div>

<p>This protocol then requires sending events back and forth with the X server, so I’ve implemented it by re-using the event polling system described in previous sections, but this time in a blocking call on the main thread. We wait to receive specific events, or abort in case of timeout.</p>

<p>Pull Request: <a href="https://github.com/godotengine/godot/pull/42652">GH-42652</a></p>

<h4 id="3-incr-protocol-handle-large-amount-of-data-from-other-apps">3. INCR protocol (handle large amount of data from other apps)</h4>

<p>Another limitation of the X11 clipboard is it doesn’t allow sending data over 256KB at once.</p>

<p>That was causing issues when pasting large amounts of text, and the only way to solve it is by implementing the <code class="language-plaintext highlighter-rouge">INCR</code> protocol, which allows sending data in chunks through the X server.</p>

<p>It mostly consists in detecting we’re receiving incremental data when accessing the clipboard selection property:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Set the selection atom to XA_PRIMARY, the main clipboard selection.
Atom selection = XA_PRIMARY;

// Get the selection property value, which type is not always the same.
Atom type;
int format = 0;
unsigned long len = 0;
unsigned long remaining = 0;
unsigned char *data = nullptr;
XGetWindowProperty(x11_display, x11_window, XA_PRIMARY,
        0, // data offset
        0, // data length
        False, // should the property be deleted?
        AnyPropertyType, // expected property type
        &amp;type, // returned property type
        &amp;format, // returned data format
        &amp;len, // returned data length
        &amp;remaining, // returned remaining length for partial data
        &amp;data); // returned data pointer

// Get INCR atom from name.
Atom incr_prop = XInternAtom(x11_display, "INCR", False);

// Check if the selection data is actually of type INCR.
if (type == incr_prop) {
    // Handle INCR protocol (see PR for more details).
}
</code></pre></div></div>

<p>Because this protocol requires asynchronous communication to receive each chunk of data and send notifications for the next one, I’ve implemented it in a similar way as for <code class="language-plaintext highlighter-rouge">SAVE_TARGETS</code>, with a blocking call that handles all events or aborts in the case of timeout.</p>

<p>More details about <code class="language-plaintext highlighter-rouge">INCR</code> protocol in the X11 documentation <a href="https://www.x.org/releases/X11R7.6/doc/xorg-docs/specs/ICCCM/icccm.html#incr_properties">here</a>.</p>

<p>Pull Request: <a href="https://github.com/godotengine/godot/pull/42676">GH-42676</a></p>

<h1 id="what-next">What next?</h1>

<p>After completing this work package, most regressions related to X11 should be fixed now for Godot 4, even if there will still be some maintenance to do on all platforms before the release.</p>

<p><strong>Xlib or XCB:</strong> While working on the X11 Display Server, I’ve chosen to focus on fixing specific issues in the current system with minimal refactoring, but using XCB to modernize the implementation is currently in discussion among contributors.</p>

<p><strong>Wayland:</strong> Support for Wayland will be added to Godot in the future. It will be done as a separate Display Server implementation.</p>

<p>I hope this post put some light on the way Godot works under the hood in this specific area, for current and future contributors. See you around!</p>

<hr />

<p><em>Credits illustration: Tux logo by rafael3334 (modified from <a href="https://www.onlinewebfonts.com/icon/45465">source</a>)</em></p>

			</div>
		</div>
	</article>
</div>

<link rel="stylesheet" href="/assets/css/anchor-link.css?1">
<link rel="stylesheet" href="/assets/css/article-cards.css?2">
<script src="/assets/js/anchor-link.js"></script>
<script>
	document.addEventListener('DOMContentLoaded', () => {
		// Add icons to easily copy section links.
		window.applyAnchorLinks('.article-body');

		// Add lightbox elements in blog articles for Tobii.
		document.querySelectorAll('.article-cover img, .article-body img').forEach((articleImg) => {
			if (articleImg.classList.contains('lightbox-ignore')) {
				return;
			}

			const lightbox = document.createElement('a');
			lightbox.href = articleImg.src;
			lightbox.classList.add('lightbox');
			lightbox.dataset.group = 'article';
			articleImg.parentNode.appendChild(lightbox);
			lightbox.appendChild(articleImg);
		});
	});
</script>

</main>

<footer>
	<div class="container flex footer-container">
		<div id="copyright">
			<p>
				© 2007-2024 Juan Linietsky, Ariel Manzur and <a
					href="https://github.com/godotengine/godot/blob/master/AUTHORS.md" target="_blank"
					rel="noopener">contributors</a>.<br>
				Hosted by the <a href="https://godot.foundation/" target="_blank" rel="noopener">Godot Foundation</a>.<br>
				Website <a href="https://github.com/godotengine/godot-website" target="_blank" rel="noopener">source code on  GitHub</a>.
			</p>
		</div>
		<div id="sitemap">
			<ul class="sitemap-group">
				<li><strong>Get Godot</strong></li>
				<li><a href="/download/windows" class="set-os-download-url">Download</a></li>
				<li><a href="https://editor.godotengine.org/releases/latest/">Web Editor</a></li>
				<li>&nbsp;</li>
				<li><strong>Public Relations</strong></li>
				<li><a href="/blog">Blog</a></li>
				<li><a href="/community">Communities and Events</a></li>
				<li><a href="/press">Press Kit</a></li>
			</ul>
			<ul class="sitemap-group">
				<li><strong>About Godot</strong></li>
				<li><a href="/features">Features</a></li>
				<li><a href="/showcase">Showcase</a></li>
				<li><a href="/education">Education</a></li>
				<li><a href="/license">License</a></li>
				<li><a href="/code-of-conduct">Code of Conduct</a></li>
				<li><a href="/privacy-policy">Privacy Policy</a></li>
				<li><a href="https://fund.godotengine.org">Donate</a></li>
			</ul>
			<ul class="sitemap-group">
				<li><strong>Project Team</strong></li>
				<li><a href="/governance">Governance</a></li>
				<li><a href="/teams">Teams</a></li>
				<li>&nbsp;</li>
				<li><strong>Extra Resources</strong></li>
				<li><a href="/asset-library/asset">Asset Library</a></li>
				<li><a href="https://docs.godotengine.org">Documentation</a></li>
				<li><a href="https://github.com/godotengine">Code Repository</a></li>
			</ul>
		</div>
		<div id="social" class="dark-desaturate">
			<h4 class="text-right"><a href="/contact">Contact us</a></h4>
			<div class="flex justify-space-between" style="gap: 3px;">
				<a href="https://github.com/godotengine" target="_blank" rel="noopener">
					<img src="/assets/footer/github_logo.svg" width="32" height="32" alt="GitHub">
				</a>
				<a href="https://mastodon.gamedev.place/@godotengine" target="_blank" rel="noopener">
					<img src="/assets/footer/mastodon_logo.svg" width="32" height="32" alt="Mastodon">
				</a>
				<a href="https://twitter.com/godotengine" target="_blank" rel="noopener">
					<img src="/assets/footer/twitter_logo.svg" width="32" height="32" alt="Twitter">
				</a>
				<a href="https://www.facebook.com/groups/godotengine/" target="_blank" rel="noopener">
					<img src="/assets/footer/facebook_logo.svg" width="32" height="32" alt="Facebook">
				</a>
				<a href="https://www.reddit.com/r/godot" target="_blank" rel="noopener">
					<!-- Zero-width space in the `alt` text to prevent content blockers from blocking the icon -->
					<img src="/assets/footer/reddit_logo.svg" width="32" height="32" alt="Red​dit">
				</a>
				<a href="/rss.xml" target="_blank" rel="noopener">
					<!-- Icon is called `feed` instead of `rss` to prevent content blockers from blocking the icon -->
					<img src="/assets/footer/feed_logo.svg" width="32" height="32" alt="RSS feed">
				</a>
			</div>
		</div>
	</div>
</footer>

<script defer src="/assets/js/tobii.min.js"></script>
<script defer src="/assets/js/highlight.min.js?1"></script>
<script defer src="/assets/js/highlight.gdscript.min.js?1"></script>
<script>
	document.addEventListener('DOMContentLoaded', () => {
		// This needs to be done on page load but also after page changes,
		// in case a code block appears in an article.
		document.querySelectorAll('pre code').forEach((block) => {
			hljs.highlightBlock(block);
		});

		document.querySelectorAll('[data-post-date]').forEach((postDate) => {
			// Highlight post dates that are less than 48 hours old.
			if (Date.parse(postDate.dataset.postDate) > (Date.now() - 1000 * 60 * 60 * 48)) {
				postDate.classList.add("post-recent-highlight");
			};
		});

		// Initialize lightbox.
		new Tobii({
			zoom: false,
		});

		// Update any download link to point to identified user's OS.
		const links = document.querySelectorAll('.set-os-download-url');
		for (let i = 0; i < links.length; i++) {
			const link = links[i];
			let link_slug = 'download';
			if ('version' in link.dataset && link.dataset['version'] === '3') {
				link_slug = 'download/3.x';
			}

			let link_platform = 'windows';
			if (navigator.platform.indexOf('Mac') !== -1) {
				link_platform = 'macos';
			} else if (navigator.platform.indexOf('Linux') !== -1) {
				link_platform = 'linux';
			}

			link.href = `/${link_slug}/${link_platform}`;
		}
	});
</script>


</body>

</html>
